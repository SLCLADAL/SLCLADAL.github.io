<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="UQ SLC Digital Team" />

<meta name="date" content="2019-07-16" />

<title>Text Analysis and Distant Reading</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.0.13/css/fa-svg-with-js.css" rel="stylesheet" />
<script src="site_libs/font-awesome-5.0.13/js/fontawesome-all.min.js"></script>
<script src="site_libs/font-awesome-5.0.13/js/fa-v4-shims.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">LADAL</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-play-circle"></span>
     
    Basics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Basics</li>
    <li>
      <a href="introquant.html">Introduction To Quantitative Reasoning</a>
    </li>
    <li>
      <a href="basicquant.html">Basic Concepts In Quantitative Reasoning</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Research Designs</li>
    <li>
      <a href="researchdesigns.html">Overview</a>
    </li>
    <li>
      <a href="corpling.html">Corpus Linguistics</a>
    </li>
    <li>
      <a href="experiments.html">Experimental Designs</a>
    </li>
    <li>
      <a href="ca.html">Conversation Analysis</a>
    </li>
    <li>
      <a href="acoustic.html">Acoustic Analysis</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Data Collection</li>
    <li>
      <a href="introdatacollection.html">Introduction</a>
    </li>
    <li>
      <a href="fieldwork.html">Field Work</a>
    </li>
    <li>
      <a href="interviews.html">Interviews</a>
    </li>
    <li>
      <a href="questionnaires.html">Questionnaires and Surveys</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-gear"></span>
     
    Data Processing
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Data Processing</li>
    <li>
      <a href="intror.html">Basics: Getting started with R</a>
    </li>
    <li>
      <a href="introloading.html">Loading and saving data</a>
    </li>
    <li>
      <a href="introtables.html">Tabulating data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="dataprocessingexcel.html">Data Processing with Excel</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-bar-chart"></span>
     
    Visualization
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Visualization</li>
    <li>
      <a href="basicgraphs.html">Basic Visualization with R</a>
    </li>
    <li>
      <a href="advancedgraphs.html">Basic Visualization with Excel</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-eye"></span>
     
    Statistics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Statistics</li>
    <li>
      <a href="descriptivestatz.html">Descriptive Statistics</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Basic Interential Statistics</li>
    <li>
      <a href="basicstatz.html">Basic Inferential Tests</a>
    </li>
    <li>
      <a href="basicstatzchi.html">The Chi-Square Family</a>
    </li>
    <li>
      <a href="basicstatzregression.html">Simple Linear Regression</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Advanced Interential Statistics</li>
    <li>
      <a href="advancedstatzregressions.html">Regression Analysis</a>
    </li>
    <li>
      <a href="advancedstatztrees.html">Tree-Based Models</a>
    </li>
    <li>
      <a href="groupingstatz.html">Agglomerative Procedures</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-bars"></span>
     
    Text Analysis/Corpus Linguistics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Text Analysis</li>
    <li>
      <a href="textanalysis.html">Introduction</a>
    </li>
    <li>
      <a href="webcrawling.html">Web Crawling</a>
    </li>
    <li>
      <a href="network.html">Network Analysis</a>
    </li>
    <li>
      <a href="topicmodels.html">Topic Modeling</a>
    </li>
    <li>
      <a href="classification.html">Classification</a>
    </li>
    <li>
      <a href="tagging.html">Tagging and Parsing</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Corpus Linguistics</li>
    <li>
      <a href="corplingr.html">Corpus Linguistics in R</a>
    </li>
    <li>
      <a href="corplingantconcexcel.html">Corpus Linguistics with AntConc, TextPad and Excel</a>
    </li>
    <li>
      <a href="available.html">Available Software</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="about.html">
    <span class="fa fa-info"></span>
     
    Contact
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Text Analysis and Distant Reading</h1>
<h4 class="author"><em>UQ SLC Digital Team</em></h4>
<h4 class="date"><em>2019-07-16</em></h4>

</div>


<p><img src="images/uq1.jpg" width="100%" /></p>
<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>This section introduces Text Analysis, i.e. computer-based analysis of language data or the (semi-)automated extraction of information from text. The entire code for the sections below can be downloaded <a href="https://slcladal.github.io/rscripts/textanalysisscript.r">here</a>.</p>
<p>Since Text Analysis extracts and analyses information from language data, it can be considered a derivative of computational linguistics. As such, Text Analysis represents the application of computational methods in the humanities.</p>
<p>The advantage of Text Analysis over manual or traditional techniques (close reading) lies in the fact that Text Analysis allows the extraction of information from large sets of textual data and in a replicable manner. Other terms that are more or less synonymous with Text Analysis are Text Mining, Text Analytics, and Distant Reading. In some cases, Text Analysis is considered more qualitative while Text Analytics is considered to be quantitative. This distinction is not taken up here as Text Analysis, while allowing for qualitative analysis, builds upon quantitative information, i.e. information about frequencies or conditional probabilities.</p>
<div class="figure">
<img src="textanalysis_files/figure-html/Fig1-1.png" alt="\label{fig:Fig1} Google N-Gram Viewer results for “ communist “,” terror “,” democratic “,” liberal “, and “ terror “ from 1820 to 2008." width="576" />
<p class="caption">
 Google N-Gram Viewer results for “ communist “,” terror “,” democratic “,” liberal “, and “ terror “ from 1820 to 2008.
</p>
</div>
<p>Distant Reading is a cover term for applications of Text Analysis that allow to investigate literary and cultural trends using text data. Distant Reading contrasts with close reading, i.e. reading texts in the traditional sense whereas Distant Reading refers to the analysis of large amounts of text. Text Analysis and distant reading are similar with respect to the methods that are used but different with respect to their outlook. The outlook of distant reading is to extract information from text without close reading, i.e. reading the document(s) itself but rather focusing on emerging patterns in the language that is used.</p>
<p>Text Analysis or Distant Reading are rapidly growing in use gaining popularity in the humanities because textual data is readily available and because computational methods can be applied to a huge variety of research questions. The attractiveness of computational text analysis is thus based on the availability of (large amounts of) digitally available texts and in their capability to provide insights that cannot be derived from close reading techniques.</p>
<div class="figure">
<img src="textanalysis_files/figure-html/Fig2-1.png" alt="\label{fig:Fig1} Comparative network graph for personas in William Shakespeare's King Lear, Macbeth, and Orthello. (from http://www.martingrandjean.ch/network-visualization-shakespeare/." width="576" />
<p class="caption">
 Comparative network graph for personas in William Shakespeare’s King Lear, Macbeth, and Orthello. (from <a href="http://www.martingrandjean.ch/network-visualization-shakespeare/" class="uri">http://www.martingrandjean.ch/network-visualization-shakespeare/</a>.
</p>
</div>
<p>While rapidly growing as a valid approach to analysing textual data, Text Analysis is <a href="https://www.chronicle.com/article/The-Digital-Humanities-Debacle/245986">critizised</a> for lack of “quantitative rigor and because its findings are either banal or, if interesting, not statistically robust (see <a href="https://www.chronicle.com/article/The-Digital-Humanities-Debacle/245986">here</a>. This criticism is correct in that most of the analysis that performed in Computational Literary Studies (CLS) are not yet as rigorous as analyses in fields that have a longer history of computational based, quantitative research, such as, for instance, corpus linguistics. However, the practices and methods used in CLS will be refined, adapted and show a rapid increase in quality if more research is devoted to these approaches. Also, Text Analysis simply offers an alternative way to analyse texts that is not in competition to traditional techniques but rather complements them.</p>
<p>Given it relatively recent emergence, so far, most of the applications of Text Analysis are based upon a relatively limited number of key procedures or concepts (e.g. concordancing, word frequencies, annotation or tagging, parsing, collocation, text classification, Sentiment Analysis, Entity Extraction, Topic Modelling, etc.). In the following, we will explore these procedures and introduce some basic tools that help you perform the introduced tasks.</p>
</div>
<div id="text-analysis-at-uq" class="section level1">
<h1><span class="header-section-number">2</span> Text Analysis at UQ</h1>
<p>The <a href="https://www.library.uq.edu.au/">UQ Library</a> offers a very handy and attractive summary of <a href="https://guides.library.uq.edu.au/research-techniques/text-mining-analysis/introduction">resources, concepts, and tools</a> that can be used by researchers interested in Text Analysis and Distant Reading. Also, the UQ library site offers short video introductions and addresses issues that are not discussed here such as <a href="https://guides.library.uq.edu.au/research-techniques/text-mining-analysis/considerations">copyright issues</a>, <a href="https://guides.library.uq.edu.au/research-techniques/text-mining-analysis/sources-of-text-data">data sources available at the UQ library</a>, as well as <a href="https://guides.library.uq.edu.au/research-techniques/text-mining-analysis/sources-of-text-data">social media</a> and <a href="https://guides.library.uq.edu.au/research-techniques/text-mining-analysis/web-scraping">web scaping</a>.</p>
<p>In contrast to the UQ library site, the focus of this introduction lies on the practical how-to of text analysis. this means that the following concentrates on how to perform analyses rather than discussing their underlying concepts or evaluating their scientific merits.</p>
</div>
<div id="tools-versus-scripts" class="section level1">
<h1><span class="header-section-number">3</span> Tools versus Scripts</h1>
<p>It is perfectly fine to use tools for the analyses exemplified below. However, the aim here is not primarily to show how to perform text analyses but how to perfrom text analyses in a way that complies with practices that guarantee sustainable, transparent, reproducible research. As R code can be readily shared and optimally contains all the data extraction, processing, vizualization, and analysis steps, using scripts is preferable over using (commercial) software.</p>
<p>In addition to being not as transparent and hindering reproduction of research, using tools can also lead to dependencies on third parties which does not arise when using open source software.</p>
<p>Finally, the widespread use of “R” particularly among data scientists, engineers, and analysts reduces the risk of software errors as a very active community corrects flawed functions typically quite rapidly.</p>
</div>
<div id="preparation" class="section level1">
<h1><span class="header-section-number">4</span> Preparation</h1>
<p>The following sections briefly introduce some common types of Text Analysis procedures. As all examples will be performed in “R”, it is necessary to install “R”, “RStudio”, and “Tinn-R”. If these programms (or, in the case of “R”, environments) are not installed already, please search for them in your favorite serach engine and add the term “download”. Open any of the first few links and follow the installation instructions (they are easy to follow, do not require any specifications, and are pretty much self-explanatory).</p>
<p>In addition, certain “libraries” need to be installed so that the scripts shown below are executed without errors. Before turning to the code below, please install the libraries needed for running the code below. If you have already installed the libraries mentioned below, then you can skip ahead ignore this section. To install the necessary libraries, simply run the following code - it may take some time (between 1 and 5 minutes to install all of the libraries so you do not need to worry if it takes some time).</p>
<pre class="r"><code># clean current workspace
rm(list=ls(all=T))
# set options
options(stringsAsFactors = F)
# install libraries
install.packages(c(&quot;class&quot;, &quot;cluster&quot;, &quot;dplyr&quot;, &quot;factoextra&quot;, 
                   &quot;FactoMineR&quot;, &quot;ggplot2&quot;, &quot;ggraph&quot;, &quot;grid&quot;, 
                   &quot;gutenbergr&quot;, &quot;igraph&quot;, &quot;Matrix&quot;, &quot;NLP&quot;, 
                   &quot;openNLP&quot;, &quot;openNLPmodels.en&quot;, &quot;Matrix&quot;, 
                   &quot;stringr&quot;, &quot;syuzhet&quot;, &quot;tidyr&quot;, &quot;tidytext&quot;, 
                   &quot;tm&quot;, &quot;topicmodels&quot;, &quot;wordcloud&quot;, &quot;xtable&quot;))</code></pre>
<p>Once you have installed “R”, “R-Studio”, “Tinn-R”, and have also initiated the session by executing the code shown above, you are good to go.</p>
</div>
<div id="concordancing" class="section level1">
<h1><span class="header-section-number">5</span> Concordancing</h1>
<p>In Text Analysis, concordancing refers to the extraction of words from a given text or texts. Commonly, concordances are displayed in the form of KWIC displays (Key Word in Context) where the search term is shown with some preceding and following context.</p>
<div class="figure">
<img src="textanalysis_files/figure-html/Fig3-1.png" alt="\label{fig:Fig2} KWIC display of the search term language extracted from the BROWN corpus in the program AntConc." width="768" />
<p class="caption">
 KWIC display of the search term language extracted from the BROWN corpus in the program AntConc.
</p>
</div>
<p>Concordancing is helpful for inspecting how often a given word occurs in a text or a collection of texts, for seeing how the term is used in the data, for extracting examples, and it also represents a basic procedure and often the first step in more sophisticated analyses of language data.</p>
<p>In the follwoing, we will use “R” to create a KWIC display. More precisely, we will load Charles Darwin’s “On the origin of species” and investigate his use of the term “natural selection” in across chapters.</p>
<pre class="r"><code># load libraries
library(dplyr)
library(stringr)
# read in text
darwin &lt;- readLines(&quot;https://slcladal.github.io/data/origindarwin.txt&quot;) %&gt;%
  paste(sep = &quot; &quot;, collapse = &quot; &quot;) %&gt;%
  str_replace_all(&quot;(CHAPTER [XVI]{1,7}\\.{0,1}) &quot;, &quot;qwertz\\1&quot;) %&gt;%
  tolower() %&gt;%  
  strsplit(&quot;qwertz&quot;) %&gt;%
  unlist()
# inspect data
nchar(darwin)</code></pre>
<pre><code>##  [1]  10133  76155  40735  37418 121497  75187  95601 102879  83597  81774
## [11]  72427  70938  74510  53292 114321  70663</code></pre>
<p>Now that we have the subsections of the data that we aim to investigate, we can perform the concordancing. To create a KWIC display, we load the function “ConcR” from a script called “ConcR_2.3_loadedfiles.R”. Then we define a pattern that we want to look for (the pattern can be a simple word or it contain regular expressions). Then, we define the amount of context that we want to have displayed (in our case 50 characters). Finally, we run the concordance function “ConcR” with the arguments “darwin” the text elements that we want to inspect, the search pattern, and the context.</p>
<pre class="r"><code># load function for concordancing
source(&quot;https://slcladal.github.io/rscripts/ConcR_2.3_loadedfiles.r&quot;)
# start concordancing
darwinnatsel &lt;- ConcR(darwin, &quot;organism[s]{0,1}&quot;, 50)
# inspect data
darwinnatsel[1:5, 2:ncol(darwinnatsel)]</code></pre>
<pre><code>##                                           PreContext     Token
## 1                                               &lt;NA&gt;      &lt;NA&gt;
## 2 y generations. no case is on record of a variable   organism
## 3  there are two factors; namely, the nature of the   organism
## 4 ects of the conditions of life on each individual   organism
## 5 hat unlike their parents. i may add, that as some  organisms
##                                          PostContext
## 1                                               &lt;NA&gt;
## 2  ceasing to vary wnder cultivation. our oldest cul
## 3 , and the nature of the conditions. the former see
## 4 , in nearly the same manner as the chill affects d
## 5  breed freely under the most unnat- ural condition</code></pre>
<p>We now have the KWIC display but would like to clean the display and get rid of the rows that do not contain information (which happens if the search pattern does not occur in a subfile that we searched).</p>
<p>In addition, we want to extract the chapter in which the instance has occurred.</p>
<pre class="r"><code># clean data
darwinnatsel1 &lt;- darwinnatsel[complete.cases(darwinnatsel),]
# determine chapter
darwinnatsel1$Chapter &lt;- ifelse(grepl(&quot;chapter [xvi]{1,7}\\.{0,1} .*&quot;, darwinnatsel1$OriginalString) == T, gsub(&quot;(chapter [xvi]{1,7})\\.{0,1} .*&quot;, &quot;\\1&quot;, darwinnatsel1$OriginalString), darwinnatsel1$OriginalString)
# remove OriginalString column 
darwinnatsel1$OriginalString &lt;- NULL
# inspect data
head(darwinnatsel1)</code></pre>
<pre><code>##                                           PreContext     Token
## 2 y generations. no case is on record of a variable   organism
## 3  there are two factors; namely, the nature of the   organism
## 4 ects of the conditions of life on each individual   organism
## 5 hat unlike their parents. i may add, that as some  organisms
## 6 e importance in comparison with the nature of the   organism
## 7 likewise neces- sarily occurs with closely allied  organisms
##                                          PostContext    Chapter
## 2  ceasing to vary wnder cultivation. our oldest cul  chapter i
## 3 , and the nature of the conditions. the former see  chapter i
## 4 , in nearly the same manner as the chill affects d  chapter i
## 5  breed freely under the most unnat- ural condition  chapter i
## 6  in determining each particular form of variation   chapter i
## 7 , which inhabit distinct continents or islands. wh chapter ii</code></pre>
<p>Now, the KWIC display is finished and we could go about investigating how Darwin has used the term “organism”.</p>
</div>
<div id="word-frequency" class="section level1">
<h1><span class="header-section-number">6</span> Word Frequency</h1>
<p>One basic aspect of Text Analysis consists in extracting word frequency lists, i.e. determining how often word forms occur in a given text or collection of texts. In fact, frequency information lies at the very core of Text Analysis.</p>
<p>To exemplify how frequency information can help us in an analysis, we will continue working with the KWIC display that we have created above.</p>
<p>In the following, we want to find out about changes in the frequency with which the term “organism” has been used across chapters in Darwin’s “Origin”.</p>
<p>In a first step, we extract the number of words in each chapter.</p>
<pre class="r"><code># extract number of words per chapter
library(dplyr)
darwinchapters &lt;- darwin %&gt;%
  strsplit(&quot; &quot;)
words &lt;- sapply(darwinchapters, function(x) length(x))
# inspect data
words</code></pre>
<pre><code>##  [1]  1855 14064  7455  7135 22316 13915 17780 19054 15846 14740 13312
## [12] 12995 13752  9816 20966 12986</code></pre>
<p>Next, we extract the number of matches in each chapter.</p>
<pre class="r"><code># extract number of matches per chapter
library(stringr)
matcheschapters &lt;- darwin %&gt;%
  str_extract_all(., &quot;organism[s]{0,1}&quot;) 
matches &lt;- sapply(matcheschapters, function(x) length(x))
# inspect data
matches</code></pre>
<pre><code>##  [1]  0  5  3  3  9  3  3  3  0  1  6  6 10  5  8  7</code></pre>
<p>Now, we extract the names of the chapters and create a table with the chapter names and the relative frequency of matches per 1,000 words.</p>
<pre class="r"><code># extract chapters
Chapters &lt;- as.vector(unlist(sapply(darwin, function(x){
  x &lt;- gsub(&quot;(chapter [xvi]{1,7})\\.{0,1} .*&quot;, &quot;\\1&quot;, x)
  x &lt;- ifelse(nchar(x) &gt; 50, &quot;chapter 0&quot;, x)
})))
# calculate rel. freq of serach term per chapter 
Frequency &lt;- matches/words*1000
# create table of results
tb &lt;- data.frame(Chapters, Frequency)
# inspect results
head(tb)</code></pre>
<pre><code>##      Chapters Frequency
## 1   chapter 0 0.0000000
## 2   chapter i 0.3555176
## 3  chapter ii 0.4024145
## 4 chapter iii 0.4204625
## 5  chapter iv 0.4032981
## 6   chapter v 0.2155947</code></pre>
<p>We can now visualize the relative frequencies of our search word per chapter.</p>
<pre class="r"><code># load library
library(ggplot2)
# create plot
ggplot(tb, aes(x=Chapters, y=Frequency, group =1)) + 
  geom_smooth(aes(y = Frequency, x = Chapters), color = &quot;goldenrod2&quot;)+
  geom_line(aes(y = Frequency, x = Chapters), color = &quot;indianred4&quot;) +         
  guides(color=guide_legend(override.aes=list(fill=NA))) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  scale_y_continuous(name =&quot;Relative Frequency (per 1,000 words)&quot;)</code></pre>
<p><img src="textanalysis_files/figure-html/wf4-1.png" width="672" /></p>
<p>We will now briefly check an example where we simply extract a frequency list from a corpus.</p>
<pre class="r"><code># load library
library(tm)
# load and process corpus
corpuswords &lt;- readLines(&quot;https://slcladal.github.io/data/origindarwin.txt&quot;)  %&gt;%
  tolower() %&gt;%
  removeWords(stopwords(&quot;english&quot;)) %&gt;% 
  str_replace_all(&quot;[^[:alpha:][:space:]]*&quot;, &quot;&quot;)  %&gt;%
  paste(sep = &quot; &quot;, collapse = &quot; &quot;) %&gt;%
  str_replace_all(&quot; {2,}&quot;, &quot; &quot;) %&gt;%
  strsplit(&quot; &quot;) %&gt;%
  unlist()  
# create table
wordfreqs &lt;- corpuswords %&gt;%
  table() %&gt;%
  as.data.frame() %&gt;%
  arrange(desc(Freq))
# add column names
colnames(wordfreqs) &lt;- c(&quot;Word&quot;, &quot;Frequency&quot;)
# inspect data
head(wordfreqs)</code></pre>
<pre><code>##      Word Frequency
## 1 species      1755
## 2     one       777
## 3    will       757
## 4     may       650
## 5    many       590
## 6     can       583</code></pre>
<p>Such word frequency lists can be visualized, for example, as bargraphs.</p>
<pre class="r"><code># prepare data
wfd &lt;- table(corpuswords)
wfd &lt;- wfd[order(wfd, decreasing = T)]
wfd &lt;- wfd[1:10]
# start plot
barplot(wfd, las = 1, ylim = c(0,2000), las=2)
text(seq(0.7, 11.5, 1.2), wfd+150, wfd)</code></pre>
<p><img src="textanalysis_files/figure-html/wf6-1.png" width="672" /></p>
<p>Alternatively, word frequency lists can be visualized, although less informative, as word clouds.</p>
<pre class="r"><code># load library
library(&quot;wordcloud&quot;)
# create wordcloud
wordcloud(words = wordfreqs$Word, freq = wordfreqs$Frequency, 
          max.words=100, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, &quot;BrBG&quot;))</code></pre>
<p><img src="textanalysis_files/figure-html/wf7-1.png" width="672" /></p>
<p>Word lists can be used to determine differences between texts. For instance, we can load two different texts and check whether they differ with respect to word frequencies.</p>
<pre class="r"><code># load data
orwell &lt;- readLines(&quot;https://slcladal.github.io/data/orwell.txt&quot;)
melville &lt;- readLines(&quot;https://slcladal.github.io/data/melvillemobydick.txt&quot;)
# combine each text into one element
orwell &lt;- paste(as.vector(unlist(orwell)), sep = &quot; &quot;, collapse = &quot; &quot;)
melville &lt;- paste(as.vector(unlist(melville)), sep = &quot; &quot;, collapse = &quot; &quot;)
# load libraries
library(tm)
library(dplyr)
library(xtable)
# clean texts
docs &lt;- Corpus(VectorSource(c(orwell, melville))) %&gt;%
  tm_map(removePunctuation) %&gt;%
  tm_map(removeNumbers) %&gt;%
  tm_map(tolower)  %&gt;%
  tm_map(removeWords, stopwords(&quot;english&quot;)) %&gt;%
  tm_map(stripWhitespace) %&gt;%
  tm_map(PlainTextDocument)
# create term document matrix
tdm &lt;- TermDocumentMatrix(docs) %&gt;%
  as.matrix()
colnames(tdm) &lt;- c(&quot;Orwell&quot;,&quot;Melville&quot;)

# create comparison cloud
comparison.cloud(tdm, random.order=FALSE, 
                 colors = c(&quot;orange&quot;,&quot;lightblue&quot;),
                 title.size=2.5, max.words=200, 
                 title.bg.colors = &quot;white&quot;)</code></pre>
<p><img src="textanalysis_files/figure-html/wf8-1.png" width="672" /></p>
<p>Frequency information can also tell us something about the nature of a text. For instance, private dialogues will typically contain higher rates of second person pronouns compared with more format text types, such as, for instance, scripted monologues like speeches. For this reason, word frequency lists can be used in text classification and to determine the formality of texts.</p>
<p>As an example, below you find the number of the second person pronouns “you” and “your” and the number of all words except for these second person pronouns in private dialogues compared with scripted monologues in the Irish component of the International corpus of English (ICE).</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="center">Private dialogues</th>
<th align="center">Scripted monologues</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>you, your</td>
<td align="center">6761</td>
<td align="center">659</td>
</tr>
<tr class="even">
<td>Other words</td>
<td align="center">259625</td>
<td align="center">105295</td>
</tr>
</tbody>
</table>
<p>If we calculate the percentage of second person pronouns in both text types and see whether private dialogues contain more of these second person pronouns than scripted monologues (i.e. speeches).</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="center">Private dialogues</th>
<th align="center">Scripted monologues</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>you, your</td>
<td align="center">6761</td>
<td align="center">659</td>
</tr>
<tr class="even">
<td>Other words</td>
<td align="center">259625</td>
<td align="center">105295</td>
</tr>
<tr class="odd">
<td>Percent</td>
<td align="center">2.60</td>
<td align="center">0.63</td>
</tr>
</tbody>
</table>
<p>This simple example shows that second person pronouns make up 2.6 percent of all words that are used in private dialogues while they only amount to 0.63 percent in scripted speeches. A handy way to present such differences visually are association and mosaic plots.</p>
<pre class="r"><code>d &lt;- matrix(c(6761, 659, 259625, 105295), nrow = 2, byrow = T)
colnames(d) &lt;- c(&quot;D&quot;, &quot;M&quot;)
rownames(d) &lt;- c(&quot;you, your&quot;, &quot;Other words&quot;)
assocplot(d)</code></pre>
<p><img src="textanalysis_files/figure-html/wf11-1.png" width="672" /></p>
<p>Bars above the dashed line indicate relative overuse while bars below the line suggest relative underuse. Therefore, the association plot indicates underuse of “you/your” and overuse of “other words” in monologues while the opposite trends holds true for dialogues, i.e. overuse of “you/your” and underuse of “Other words”.</p>
</div>
<div id="collocations-and-n-grams" class="section level1">
<h1><span class="header-section-number">7</span> Collocations and N-grams</h1>
<p>Collocation refers to the co-occurrence of words. A typical example of a collocation is “Merry Christmas” because the words merry and Christmas occur together more frequently together than would be expected by chance, if words were just randomly stringed together.</p>
<p>N-grams are related to collocates in that they represent words that occur together (bi-grams are two words that occur together, tri-grams three words and so on). Fortunately, creating N-gram lists is very easy. We will use the “Origin” to create a bi-gram list. As a first step, we load the data and split it into individual words.</p>
<pre class="r"><code># load libraries
library(dplyr)
library(stringr)
library(tm)
# read in text
darwin &lt;- readLines(&quot;https://slcladal.github.io/data/origindarwin.txt&quot;) %&gt;%
  paste(sep = &quot; &quot;, collapse = &quot; &quot;) %&gt;%
  removePunctuation() %&gt;%
  str_replace_all(&quot; {2,}&quot;, &quot; &quot;) %&gt;% 
  tolower() %&gt;%
  strsplit(&quot; &quot;) %&gt;%
  unlist()
# inspect data
head(darwin)</code></pre>
<pre><code>## [1] &quot;the&quot;     &quot;origin&quot;  &quot;of&quot;      &quot;species&quot; &quot;by&quot;      &quot;charles&quot;</code></pre>
<pre class="r"><code># create data frame
darwindf &lt;- data.frame(darwin[1:length(darwin)-1], 
                       darwin[2:length(darwin)])
# add column names
colnames(darwindf) &lt;- c(&quot;Word1&quot;, &quot;Word2&quot;)
# inspect data
head(darwindf)</code></pre>
<pre><code>##     Word1   Word2
## 1     the  origin
## 2  origin      of
## 3      of species
## 4 species      by
## 5      by charles
## 6 charles  darwin</code></pre>
<pre class="r"><code># create data frame
darwin2grams &lt;- paste(darwindf$Word1, darwindf$Word2, sep = &quot; &quot;)
# tabulate results
darwin2gramstb &lt;- table(darwin2grams)
# create data frame
darwin2gramsdf &lt;- data.frame(darwin2gramstb)
# order data frame
darwin2gramsdf &lt;- darwin2gramsdf[order(darwin2gramsdf$Freq, decreasing = T),]
# simplify column names
colnames(darwin2gramsdf) &lt;- c(&quot;Bigram&quot;, &quot;Frequency&quot;)
# inspect data
head(darwin2gramsdf)</code></pre>
<pre><code>##          Bigram Frequency
## 47490    of the      2673
## 34249    in the      1440
## 67399  the same       959
## 71688    to the       790
## 48173    on the       744
## 30694 have been       624</code></pre>
<p>Both N-grams and collocations are not only an important concept in language teaching but they are also fundamental in Text Analysis and many other research areas working with language data. Unfortunately, words that collocate do not have to be immediately adjacent but can also encompass several slots. This is unfortunate because it makes retrieval of collocates substantially more difficult compared with a situation in which we only need to extract words that occur right next to each other.</p>
<p>In the following, we will extract collocations from Darwin’s “Origin”. In a first step, we will split the Origin into smaller chunks.</p>
<pre class="r"><code># read in text
darwinsentences &lt;- readLines(&quot;https://slcladal.github.io/data/origindarwin.txt&quot;) %&gt;%
  paste(sep = &quot; &quot;, collapse = &quot; &quot;) %&gt;%
  str_replace_all(&quot; {2,}&quot;, &quot; &quot;) %&gt;%
  str_replace_all(&quot;([A-Z]{2,} [A-Z]{2,}) ([A-Z][a-z]{1,} )&quot;, &quot;\\1 qwertz\\2&quot;) %&gt;%
  str_replace_all(&quot;([a-z]{2,}\\.) ([A-Z] {0,1}[a-z]{0,30})&quot;, &quot;\\1qwertz\\2&quot;) %&gt;%
    str_replace_all(&quot;([a-z]{2,}\\?) ([A-Z] {0,1}[a-z]{0,30})&quot;, &quot;\\1qwertz\\2&quot;) %&gt;%
  strsplit(&quot;qwertz&quot;)%&gt;%
  unlist()
# inspect data
head(darwinsentences)</code></pre>
<pre><code>## [1] &quot;THE ORIGIN OF SPECIES BY CHARLES DARWIN AN HISTORICAL SKETCH OF THE PROGRESS OF OPINION ON THE ORIGIN OF SPECIES INTRODUCTION &quot;                                                                                                                                                
## [2] &quot;When on board H.M.S. &#39;Beagle,&#39; as naturalist, I was much struck with certain facts in the distribution of the organic beings in- habiting South America, and in the geological relations of the present to the past inhabitants of that continent.&quot;                            
## [3] &quot;These facts, as will be seen in the latter chapters of this volume, seemed to throw some light on the origin of species — that mystery of mysteries, as it has been called by one of our greatest philosophers.&quot;                                                               
## [4] &quot;On my return home, it occurred to me, in 1837, that something might perhaps be made out on this question by patiently accumulating and reflecting on all sorts of facts which could possibly have any bearing on it.&quot;                                                          
## [5] &quot;After five years&#39; work I allowed myself to specu- late on the subject, and drew up some short notes; these I enlarged in 1844 into a sketch of the conclusions, which then seemed to me probable; from that period to the present day I have steadily pursued the same object.&quot;
## [6] &quot;I hope that I may be excused for entering on these personal details, as I give them to show that I have not been hasty in coming to a decision.&quot;</code></pre>
<p>In a next step, we will create a matrix that shows cooccurrence of words.</p>
<pre class="r"><code># convert into corpus
darwincorpus &lt;- Corpus(VectorSource(darwinsentences))
# create vector with words to remove
extrawords &lt;- c(&quot;the&quot;, &quot;can&quot;, &quot;get&quot;, &quot;got&quot;, &quot;can&quot;, &quot;one&quot;, 
                &quot;dont&quot;, &quot;even&quot;, &quot;may&quot;, &quot;but&quot;, &quot;will&quot;, 
                &quot;much&quot;, &quot;first&quot;, &quot;but&quot;, &quot;see&quot;, &quot;new&quot;, 
                &quot;many&quot;, &quot;less&quot;, &quot;now&quot;, &quot;well&quot;, &quot;like&quot;, 
                &quot;often&quot;, &quot;every&quot;, &quot;said&quot;, &quot;two&quot;)
# clean corpus
darwincorpusclean &lt;- darwincorpus %&gt;%
  tm_map(removePunctuation) %&gt;%
  tm_map(tolower) %&gt;%
  tm_map(removeWords, stopwords(kind = &quot;en&quot;)) %&gt;%
  tm_map(removeWords, extrawords)
# create document term matrix
darwindtm &lt;- DocumentTermMatrix(darwincorpusclean, control=list(bounds = list(global=c(1, Inf)), weighting = weightBin))
# load library
library(Matrix)
# convert dtm into sparse matrix
darwinsdtm &lt;- sparseMatrix(i = darwindtm$i, j = darwindtm$j, 
                           x = darwindtm$v, 
                           dims = c(darwindtm$nrow, darwindtm$ncol),
                           dimnames = dimnames(darwindtm))
# calculate cooccurrence counts
coocurrences &lt;- t(darwinsdtm) %*% darwinsdtm
# convert into matrix
collocates &lt;- as.matrix(coocurrences)
# inspect results
collocates[1:8, 1:5]</code></pre>
<pre><code>##              charles darwin historical introduction opinion
## charles            9      1          1            1       1
## darwin             1      1          1            1       1
## historical         1      1          4            1       1
## introduction       1      1          1            7       1
## opinion            1      1          1            1      10
## origin             1      1          2            2       1
## progress           1      1          1            1       1
## sketch             1      1          1            1       1</code></pre>
<pre class="r"><code># inspect size of matrix
ncol(collocates)</code></pre>
<pre><code>## [1] 10548</code></pre>
<pre class="r"><code>summary(rowSums(collocates))</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##       1      23      45     191     124   25722</code></pre>
<pre class="r"><code># remove terms that do not collocate with other terms
noncoll &lt;- colnames(collocates)[which(rowSums(collocates) &lt; 5000)]
# remove non-collocating terms
collocates &lt;- collocates[!rownames(collocates) %in% noncoll, ]
collocates &lt;- collocates[, !colnames(collocates) %in% noncoll]
# create distance matrix
distmtx &lt;- dist(collocates)
# activate library
library(&quot;cluster&quot;)         # activate library
clustertexts &lt;- hclust(    # hierarchical cluster object
  distmtx,                 # use data diststudents
  method=&quot;ward.D2&quot;)         # ward.D as linkage method
plot(clustertexts,         # plot result as dendrogram
     hang = .25,           # labels at split
     main = &quot;&quot;)            # no title</code></pre>
<p><img src="textanalysis_files/figure-html/coll7-1.png" width="672" /></p>
<p>An alternative way to display cooccurrence patterns are bi-plots. Biplots are commonly used to display, for instance, the results of Correspondence Analyses.</p>
<pre class="r"><code># load library
library(&quot;FactoMineR&quot;)
library(&quot;factoextra&quot;)
# perform correspondence analysis
res.ca &lt;- CA(collocates, graph = FALSE)
# cerate bi-plot
#fviz_ca_biplot(res.ca, repel = F, select.ind = list(cos2 = .02))
plot(res.ca, shadow = T, cex = 1, selectRow = &quot;cos2 0.1&quot;, selectCol = &quot;cos2 0.9&quot;, col.row = &quot;gray50&quot;, title = &quot;&quot;)</code></pre>
<p><img src="textanalysis_files/figure-html/coll8-1.png" width="672" /></p>
<p>The bi-plot shows that “natural” and “selection” collocate, as do “animals” and “plants”, “period”, “long”, and “time” as well as “conditions” and “life”. Other words with lower collocation strength are masked from the bi-plot.</p>
<p>We will now use an example of one individual word to show, how collocation strength for individual terms is calculated and displayed as a network.</p>
<pre class="r"><code># load function for co-occurrence calculation
source(&quot;rscripts/calculateCoocStatistics.R&quot;)
# define minimum number of cooccurences
numberOfCoocs &lt;- 10
# define term
coocTerm &lt;- &quot;selection&quot;
# calculate cooccurence statistics
coocs &lt;- calculateCoocStatistics(coocTerm, darwinsdtm, measure=&quot;LOGLIK&quot;)
# show strenght of cooccurence
print(coocs[1:numberOfCoocs])</code></pre>
<pre><code>##       natural        theory    variations       effects          acts 
##    1476.38620     121.48373     112.17318      66.45145      51.64986 
## modifications        sexual         power        slight        disuse 
##      45.69396      44.95857      43.80820      42.97196      41.69089</code></pre>
<p>Now, we can visualize the collocation network for our example term. Unfortunately, creating a graph object is rather complex.</p>
<pre class="r"><code># create graph object
resultGraph &lt;- data.frame(from = character(), to = character(), sig = numeric(0))
# create data frame
tmpGraph &lt;- data.frame(from = character(), to = character(), sig = numeric(0))
# fill data frame to produce the correct number of lines
tmpGraph[1:numberOfCoocs, 3] &lt;- coocs[1:numberOfCoocs]
# enter search word into the first column in all lines
tmpGraph[, 1] &lt;- coocTerm
# enter co-occurrences into second column
tmpGraph[, 2] &lt;- names(coocs)[1:numberOfCoocs]
# enter collocation strength
tmpGraph[, 3] &lt;- coocs[1:numberOfCoocs]
# attach data frame to resultGraph
resultGraph &lt;- rbind(resultGraph, tmpGraph)</code></pre>
<p>Calculate cooccurence statistics and add them to the graph object.</p>
<pre class="r"><code># iterate over most significant numberOfCoocs co-occurrences
for (i in 1:numberOfCoocs){
  # calculate co-occurrence strength for term i
  newCoocTerm &lt;- names(coocs)[i]
  coocs2 &lt;- calculateCoocStatistics(newCoocTerm, darwinsdtm, measure=&quot;LOGLIK&quot;)
  # fill temporary graph object
  tmpGraph &lt;- data.frame(from = character(), to = character(), sig = numeric(0))
  tmpGraph[1:numberOfCoocs, 3] &lt;- coocs2[1:numberOfCoocs]
  tmpGraph[, 1] &lt;- newCoocTerm
  tmpGraph[, 2] &lt;- names(coocs2)[1:numberOfCoocs]
  tmpGraph[, 3] &lt;- coocs2[1:numberOfCoocs]
  # append results to the result graph data frame
  resultGraph &lt;- rbind(resultGraph, tmpGraph[2:length(tmpGraph[, 1]), ])
}</code></pre>
<p>Now, we can create a network graph object.</p>
<pre class="r"><code># load packages
library(igraph)
# define graph and type (&quot;F&quot; means &quot;Force Directed&quot;)
graphNetwork &lt;- graph.data.frame(resultGraph, directed = F)
# identify nodes with fewer than 2 edges
graphVs &lt;- V(graphNetwork)[degree(graphNetwork) &lt; 2]
# removed these edges from graph
graphNetwork &lt;- delete.vertices(graphNetwork, graphVs) 
# sssign colors to edges and nodes (searchterm blue, rest orange)
V(graphNetwork)$color &lt;- ifelse(V(graphNetwork)$name == coocTerm, &#39;cornflowerblue&#39;, &#39;orange&#39;) 
# Edges with a significance of at least 50% of the maximum significance in the graph are drawn in orange
halfMaxSig &lt;- max(E(graphNetwork)$sig) * 0.5
E(graphNetwork)$color &lt;- ifelse(E(graphNetwork)$sig &gt; halfMaxSig, &quot;coral&quot;, &quot;azure3&quot;)
# disable edges with radius
E(graphNetwork)$curved &lt;- 0 
# size the nodes by their degree of networking
V(graphNetwork)$size &lt;- log(degree(graphNetwork)) * 5
# all nodes must be assigned a standard minimum-size
V(graphNetwork)$size[V(graphNetwork)$size &lt; 5] &lt;- 3 
# edge thickness
E(graphNetwork)$width &lt;- 1.5</code></pre>
<p>And finally, we can visualize the network.</p>
<pre class="r"><code># Define the frame and spacing for the plot
par(mai=c(0,0,1,0)) 
# Finaler Plot
plot(graphNetwork,              
     layout = layout.fruchterman.reingold,  # Force Directed Layout 
     main = paste(&quot;Cooccurrence network for&quot;, &quot; \&quot;&quot;, coocTerm, &quot;\&quot;&quot;),
     vertex.label.family = &quot;sans&quot;,
     vertex.label.cex = .75,
     vertex.shape = &quot;circle&quot;,
     vertex.label.dist = 2,           # Labels of the nodes moved slightly
     vertex.frame.color = &#39;darkolivegreen&#39;,
     vertex.label.color = &#39;black&#39;,      # Color of node names
     vertex.label.font = 2,         # Font of node names
     vertex.label = V(graphNetwork)$name,       # node names
     vertex.label.cex = .75 # font size of node names 
)</code></pre>
<p><img src="textanalysis_files/figure-html/coll14-1.png" width="672" /></p>
</div>
<div id="tagging-and-annotation" class="section level1">
<h1><span class="header-section-number">8</span> Tagging and Annotation</h1>
<p>Tagging or annotation refers to a process in which information is added to existing text. The annotation can be very different depending on the task at hand. The most common type of annotation when it comes to language data is part-of-speech tagging where the word class is determined for each word in a text and the word class is then added to the word as a tag. However, there are many different ways to tag or annotate texts. Sentiment Analysis, for instance, also annotates texts or words with respect to its or their emotional value or polarity. In fact, annotation is required in many machine-learning contexts because annotated texts represent a training set on which an algorithm is trained that then predicts for unknown items what values they would most likely be assigned if the annotation were done manually.</p>
<div id="part-of-speech-tagging-pos-tagging" class="section level2">
<h2><span class="header-section-number">8.1</span> Part-of-speech tagging (pos tagging)</h2>
<p>For many analyses that use language data it is useful or even important to differentiate between different parts of speech. In order to determine the word class of a certain word, we use a procedure which is called part-of-speech tagging or pos-tagging for short. Part-of-speech tagging is offered by many online services (e.g. XXX).</p>
<pre class="r"><code># load corpus data
text &lt;- readLines(&quot;https://slcladal.github.io/data/text2.txt&quot;, skipNul = T)
# clean data
text &lt;- text[5] %&gt;%
  removeNumbers() %&gt;%
  stripWhitespace() %&gt;%
  str_replace_all(&quot;\&quot;&quot;, &quot;&quot;)  %&gt;%
  str_replace_all(&quot;When Harry.*&quot;, &quot;&quot;)  %&gt;%
  strsplit(&quot;qwertz&quot;) %&gt;%
  unlist() %&gt;%
  stripWhitespace() 
# inspect data
str(text)</code></pre>
<pre><code>##  chr &quot;By chance, Harry encounters the man who gave him the book, just as the man has attended a funeral. He inquires &quot;| __truncated__</code></pre>
<pre class="r"><code># load function
source(&quot;https://slcladal.github.io/rscripts/POStagObject.r&quot;) # for pos-tagging objects in R
# load libraries
library(NLP)
library(openNLP)
library(openNLPmodels.en)
# detach ggplot2 library becuase function &quot;annotate&quot; 
# would be taken from ggplot2 rather than NLP
detach(&quot;package:factoextra&quot;, unload=TRUE)
detach(&quot;package:ggplot2&quot;, unload=TRUE)
# pos tagging data
textpos &lt;- POStag(object = text)
textpos</code></pre>
<pre><code>## [[1]]
## [1] &quot;By/IN chance/NN ,/, Harry/NNP encounters/VBZ the/DT man/NN who/WP gave/VBD him/PRP the/DT book/NN ,/, just/RB as/IN the/DT man/NN has/VBZ attended/VBN a/DT funeral/NN ./. He/PRP inquires/VBZ about/IN the/DT magic/JJ theater/NN ,/, to/TO which/WDT the/DT man/NN replies/VBZ ,/, Not/RB for/IN everybody/NN ./.&quot;</code></pre>
</div>
<div id="syntactic-parsing" class="section level2">
<h2><span class="header-section-number">8.2</span> Syntactic Parsing</h2>
<p>Parsing refers to another type of annotation in which either structural information (as in the case of XML documents) or syntactic relations are added to text. As syntactic parsing is commonly more relevant in the language sciences, the following will focus only on syntactic parsing. syntactic parsing builds on PoS-tagging and allows drawing syntactic trees or dependencies. Unfortunately, syntactic parsing still has relatively high error rates when dealing with language that is not very formal. However, syntactic parsing is very reliable when dealing with written language.</p>
<pre class="r"><code># extract text
text &lt;- gsub(&quot;He inquires.*&quot;, &quot;&quot;, text)
# convert character to string
s &lt;- as.String(text)
# define sentence and word token annotator
sent_token_annotator &lt;- Maxent_Sent_Token_Annotator()
word_token_annotator &lt;- Maxent_Word_Token_Annotator()
# apply sentence and word annotatior
a2 &lt;- annotate(s, list(sent_token_annotator, word_token_annotator))
# define syntactic parsing annotator
parse_annotator &lt;- Parse_Annotator()
# apply parser
p &lt;- parse_annotator(s, a2)
# extract parsed information
ptexts &lt;- sapply(p$features, &#39;[[&#39;, &quot;parse&quot;)
ptexts</code></pre>
<pre><code>## [1] &quot;(TOP (S (PP (IN By) (NP (NN chance)))(, ,) (NP (NNP Harry)) (VP (VBD encounters) (NP (NP (DT the) (NN man)) (SBAR (WHNP (WP who)) (S (VP (VBD gave) (NP (PRP him)) (NP (DT the) (NN book))(, ,) (SBAR (RB just) (IN as) (S (NP (DT the) (NN man)) (VP (VBZ has) (VP (VBN attended) (NP (DT a) (NN funeral)))))))))))(. .)))&quot;</code></pre>
<pre class="r"><code># read into NLP Tree objects.
ptrees &lt;- lapply(ptexts, Tree_parse)
# show frist tree
ptrees[[1]]</code></pre>
<pre><code>## (TOP
##   (S
##     (PP (IN By) (NP (NN chance)))
##     (, ,)
##     (NP (NNP Harry))
##     (VP
##       (VBD encounters)
##       (NP
##         (NP (DT the) (NN man))
##         (SBAR
##           (WHNP (WP who))
##           (S
##             (VP
##               (VBD gave)
##               (NP (PRP him))
##               (NP (DT the) (NN book))
##               (, ,)
##               (SBAR
##                 (RB just)
##                 (IN as)
##                 (S
##                   (NP (DT the) (NN man))
##                   (VP
##                     (VBZ has)
##                     (VP (VBN attended) (NP (DT a) (NN funeral)))))))))))
##     (. .)))</code></pre>
<p>These trees can, of course, also be shown visually, for instance, in the form of a syntax trees (or tree dendrogram).</p>
<pre class="r"><code># remove punctuation
ptexts[1] &lt;- gsub(&quot;\\(\\. \\.\\)&quot;, &quot;&quot;, ptexts[1])
ptexts[1] &lt;- gsub(&quot;\\(\\, \\,\\)&quot;, &quot;&quot;, ptexts[1])
# load library
library(igraph)
source(&quot;https://slcladal.github.io/rscripts/parsetgraph.R&quot;)
parse2graph(ptexts[1], title = &quot;&quot;, margin=-0.2, vertex.color=NA,
            vertex.frame.color=NA, vertex.label.font=2,
            vertex.label.cex=.75, vertex.label.color=&quot;black&quot;, asp=.5,
            edge.width=1, edge.color=&#39;red&#39;, edge.arrow.size=0)</code></pre>
<p><img src="textanalysis_files/figure-html/pars3-1.png" width="672" /></p>
<p>Syntax trees are very handy because the allow us to check how reliable the parser performed. In the example above, the sentence was, in fact, parsed erroneously: the clause containing the string <just as the man has attended a funeral> is dependent on the relative clause <who gave him the book> although the first clause would correctly be dependent on the clause <By chance Harry encountered the man>. However, other constituents are parsed correctly.</p>
</div>
</div>
<div id="text-classification" class="section level1">
<h1><span class="header-section-number">9</span> Text Classification</h1>
<p>Text classification refers to methods that allow to classify a given text to a predefined set of languages, genres, authors, or the like. Such classifications are typically based on the relative frequency of word classes, key words, phonemes, or other linguistic features such as average sentence length, words per line, etc.</p>
<p>As with most other methods that are used in text analysis, text classification typically builds upon a training set that is already annotated with the required tags. Training sets and the features that are derived from these training sets can be created by oneself or one can use build in training sets that are provided in the respective software packages or tools.</p>
<p>In the following, we will use the frequency of phonemes to classify a text. In a first step, we read in a German text, and split it into phonemes.</p>
<pre class="r"><code># read in German text
German &lt;- readLines(&quot;https://slcladal.github.io/data/phonemictext1.txt&quot;)
# clean text
German &lt;- gsub(&quot; &quot;, &quot;&quot;, German)
# split text into phonemes
German &lt;- strsplit(German, &quot;&quot;)
# unlist and convert into vector
German &lt;- as.vector(unlist(German))
# inspect data
head(German)</code></pre>
<pre><code>## [1] &quot;?&quot; &quot;a&quot; &quot;l&quot; &quot;s&quot; &quot;h&quot; &quot;E&quot;</code></pre>
<p>We now do the same for three other texts - an English and a Spanish text as well as one text in a language that we will determine using classification.</p>
<pre class="r"><code># read in texts
English &lt;- readLines(&quot;https://slcladal.github.io/data/phonemictext2.txt&quot;)
Spanish &lt;- readLines(&quot;https://slcladal.github.io/data/phonemictext3.txt&quot;)
Unknown &lt;- readLines(&quot;https://slcladal.github.io/data/phonemictext4.txt&quot;)
# clean, split texts into phonemes, unlist and convert them into vectors
English &lt;- as.vector(unlist(strsplit(gsub(&quot; &quot;, &quot;&quot;, English), &quot;&quot;)))
Spanish &lt;- as.vector(unlist(strsplit(gsub(&quot; &quot;, &quot;&quot;, Spanish), &quot;&quot;)))
Unknown &lt;- as.vector(unlist(strsplit(gsub(&quot; &quot;, &quot;&quot;, Unknown), &quot;&quot;)))
# inspect data
head(English, 10)</code></pre>
<pre><code>##  [1] &quot;D&quot;  &quot;@&quot;  &quot;b&quot;  &quot;U&quot;  &quot;k&quot;  &quot;I&quot;  &quot;z&quot;  &quot;p&quot;  &quot;r&quot;  &quot;\\&quot;</code></pre>
<p>We will now create a table that represents the phonemes and their frequencies in each of the 4 texts. In addition, we will add the language and simply the column names.</p>
<pre class="r"><code># create data tables
German &lt;- data.frame(names(table(German)), as.vector(table(German)))
English &lt;- data.frame(names(table(English)), as.vector(table(English)))
Spanish &lt;- data.frame(names(table(Spanish)), as.vector(table(Spanish)))
Unknown &lt;- data.frame(names(table(Unknown)), as.vector(table(Unknown)))
# add column with language
German$Language &lt;- &quot;German&quot;
English$Language &lt;- &quot;English&quot;
Spanish$Language &lt;- &quot;Spanish&quot;
Unknown$Language &lt;- &quot;Unknown&quot;
# simlify column names
colnames(German)[1:2] &lt;- c(&quot;Phoneme&quot;, &quot;Frequency&quot;)
colnames(English)[1:2] &lt;- c(&quot;Phoneme&quot;, &quot;Frequency&quot;)
colnames(Spanish)[1:2] &lt;- c(&quot;Phoneme&quot;, &quot;Frequency&quot;)
colnames(Unknown)[1:2] &lt;- c(&quot;Phoneme&quot;, &quot;Frequency&quot;)
# comine all tables into a single table
classdata &lt;- rbind(German, English, Spanish, Unknown) 
# inspect table for English
head(classdata)</code></pre>
<pre><code>##   Phoneme Frequency Language
## 1       -         6   German
## 2       :       569   German
## 3       ?       556   German
## 4       @       565   German
## 5       ¼         6   German
## 6       2         6   German</code></pre>
<p>Now, we group the data so that we see, how often each phoneme is used in each language.</p>
<pre class="r"><code># set options
options(stringsAsFactors = F)
# create wide format
classdatanew &lt;- reshape(classdata, idvar = &quot;Language&quot;, timevar = &quot;Phoneme&quot;,direction = &quot;wide&quot;)
classdw &lt;- t(apply(classdatanew, 1, function(x){ 
  x &lt;- ifelse(is.na(x) == T, 0, x)}))
# simplify column names
colnames(classdw) &lt;- gsub(&quot;Frequency.&quot;, &quot;&quot;, colnames(classdw))
# convert into data frame
classdw &lt;- as.data.frame(classdw)
# inspect data
classdw[, 1:6]</code></pre>
<pre><code>##     Language  -   :   ?   @  ¼
## 1     German  6 569 556 565  6
## 63   English  8 176   0 309  0
## 118  Spanish  5   0   0   0  0
## 168  Unknown 12 286   0 468  0</code></pre>
<p>Now, we need to transform the data again, so that we have the frequency of each phoneme by language as the classifier will use “Language” as the dependent variable and the phoneme frequencies as predictors.</p>
<pre class="r"><code>numvar &lt;- colnames(classdw)[2:length(colnames(classdw))]
classdw[numvar] &lt;- lapply(classdw[numvar], as.numeric)
# function for normalizing numeric variables
normalize &lt;- function(x) { (x -min(x))/(max(x)-min(x))   }
# apply normalization
 classdw[numvar] &lt;- as.data.frame(lapply(classdw[numvar], normalize))
 # inspect data
classdw[, 1:5]</code></pre>
<pre><code>##     Language         -         : ?         @
## 1     German 0.1428571 1.0000000 1 1.0000000
## 63   English 0.4285714 0.3093146 0 0.5469027
## 118  Spanish 0.0000000 0.0000000 0 0.0000000
## 168  Unknown 1.0000000 0.5026362 0 0.8283186</code></pre>
<p>Before turning to the actual classification, we will use a cluster analysis to see which texts the unknown text is most similar with.</p>
<pre class="r"><code># remove language column
textm &lt;- classdw[,2:ncol(classdw)]
# add languages as row names
rownames(textm) &lt;- classdw[,1]
# create distance matrix
distmtx &lt;- dist(textm)
# activate library
library(&quot;cluster&quot;)         # activate library
clustertexts &lt;- hclust(    # hierarchical cluster object
  distmtx,                 # use data diststudents
  method=&quot;ward.D&quot;)         # ward.D as linkage method
plot(clustertexts,         # plot result as dendrogram
     hang = .25,           # labels at split
     main = &quot;&quot;)            # no title</code></pre>
<p><img src="textanalysis_files/figure-html/tc6-1.png" width="672" /></p>
<p>According to the cluster analysis, the unknown text clusters together with the English texts which suggests that the unknown text is likely to be English.</p>
<p>Before we begin with the actual classification, we will split the data so that we have one data set without “Unknown” (this is our training set) and one data set with only “Unknown” (this is our test set).</p>
<pre class="r"><code>#load library
library(dplyr)
# create training set
train &lt;- classdw %&gt;%
  filter(Language != &quot;Unknown&quot;)
# increase training set size
train &lt;- rbind(train, train, train, train, train, train, train, train)
# create test set
test &lt;- classdw %&gt;%
  filter(Language == &quot;Unknown&quot;)
# convert variables
train$Language &lt;- as.factor(train$Language)
train$Language &lt;- as.factor(train$Language)
# inspect data
train[1:10, 1:3]; test[, 1:3]</code></pre>
<pre><code>##    Language         -         :
## 1    German 0.1428571 1.0000000
## 2   English 0.4285714 0.3093146
## 3   Spanish 0.0000000 0.0000000
## 4    German 0.1428571 1.0000000
## 5   English 0.4285714 0.3093146
## 6   Spanish 0.0000000 0.0000000
## 7    German 0.1428571 1.0000000
## 8   English 0.4285714 0.3093146
## 9   Spanish 0.0000000 0.0000000
## 10   German 0.1428571 1.0000000</code></pre>
<pre><code>##   Language -         :
## 1  Unknown 1 0.5026362</code></pre>
<p>Finally, we can apply our classifier to our data. The classifier we use is a k-nearest neighbour classifier as the underlying function will classify an unknown element given its proximity to the clusters in the training set.</p>
<pre class="r"><code># activate library
library(&quot;class&quot;)
# apply k-nearest-neighbor (knn) classifier
prediction &lt;- class::knn(train[,2:ncol(train)], test[,2:ncol(test)], cl = train[, 1], k = 3)
# inspect the result
prediction</code></pre>
<pre><code>## [1] English
## Levels: English German Spanish</code></pre>
<p>Based on the frequencies of phonemes in the unknown text, the knn-classifier predicts that the unknown text is English. This is in fact true as the text is a subsection of the Wikipedia article for Aldous Huxley’s “Brave New World”. The training texts were German, English, and Spanish translations of a subsection of Wikipedia’s article for Hermann Hesse’s “Steppenwolf”.</p>
</div>
<div id="sentiment-analysis" class="section level1">
<h1><span class="header-section-number">10</span> Sentiment Analysis</h1>
<p>Sentiment Analysis is a cover term for approaches which extract information on emotion or opinion from natural language. Sentiment analyses have been successfully applied to analysis of language data in a wide range of disciplines such as psychology, economics, education, as well as political and social sciences. Commonly sentiment analyses are used to determine the stance of a larger group of speakers towards a given phenomenon such as political candidates or parties, product lines or situations. Crucially, sentiment analyses are employed in these domains because they have advantages compared to alternative methods investigating the verbal expression of emotion. One advantage of sentiment analyses is that the emotion coding of sentiment analysis is fully replicable.</p>
<p>Typically, Sentiment Analysis represents a type of classifier only provide information about positive or negative polarity, e.g. whether a tweet is “positive” or “negative”. Therefore, Sentiment Analysis is often regarded as rather coarse-grained and, thus, rather irrelevant for the types of research questions in linguistics.</p>
<p>In the language sciences, Sentiment Analysis can also be a very helpful tool if the type of Sentiment Analysis provides more fine-grained information. In the following, we will perform such a information-rich Sentiment Analysis. The Sentiment Analysis used here does not only provide information about polarity but it will also provide association values for eight core emotions.</p>
<p>The more fine-grained output is made possible by relying on the Word-Emotion Association Lexicon (Mohammad &amp; Turney 2013), which comprises 10,170 terms, and in which lexical elements are assigned scores based on ratings gathered through the crowd-sourced Amazon Mechanical Turk service. For the Word-Emotion Association Lexicon raters were asked whether a given word was associated with one of eight emotions. The resulting associations between terms and emotions are based on 38,726 ratings from 2,216 raters who answered a sequence of questions for each word which were then fed into the emotion association rating (cf. Mohammad &amp; Turney 2013). Each term was rated 5 times. For 85 percent of words, at least 4 raters provided identical ratings. For instance, the word “cry” or “tragedy” are more readily associated with SADNESS while words such as “happy” or “beautiful” are indicative of JOY and words like “fit” or “burst” may indicate ANGER. This means that the sentiment analysis here allows us to investigate the expression of certain core emotions rather than merely classifying statements along the lines of a crude positive-negative distinction.</p>
<p>In the following, we will perform a sentiment analysis to investigate the emotionality of five different novels. We will start with the first example and load five pieces of literature.</p>
<pre class="r"><code># read in texts
darwin &lt;- readLines(&quot;https://slcladal.github.io/data/origindarwin.txt&quot;)
twain &lt;- readLines(&quot;https://slcladal.github.io/data/twainhuckfinn.txt&quot;)
orwell &lt;- readLines(&quot;https://slcladal.github.io/data/orwell.txt&quot;)
lovecraft &lt;- readLines(&quot;https://slcladal.github.io/data/lovecraftcolor.txt&quot;)
husband &lt;- readLines(&quot;https://slcladal.github.io/data/husbandsregret.txt&quot;)</code></pre>
<p>In a next step, we clean the data, convert it to lower case, and split it into individual words.</p>
<pre class="r"><code># clean and split files into words 
darwin &lt;- tolower(as.vector(unlist(strsplit(paste(gsub(&quot; {2,}&quot;, &quot; &quot;, darwin), sep = &quot; &quot;), &quot; &quot;))))
twain &lt;- tolower(as.vector(unlist(strsplit(paste(gsub(&quot; {2,}&quot;, &quot; &quot;, twain), sep = &quot; &quot;), &quot; &quot;))))
orwell &lt;- tolower(as.vector(unlist(strsplit(paste(gsub(&quot; {2,}&quot;, &quot; &quot;, orwell), sep = &quot; &quot;), &quot; &quot;))))
lovecraft &lt;- tolower(as.vector(unlist(strsplit(paste(gsub(&quot; {2,}&quot;, &quot; &quot;, lovecraft), sep = &quot; &quot;), &quot; &quot;))))
husband &lt;- tolower(as.vector(unlist(strsplit(paste(gsub(&quot; {2,}&quot;, &quot; &quot;, husband), sep = &quot; &quot;), &quot; &quot;))))</code></pre>
<p>Now, we extract samples from each data set.</p>
<pre class="r"><code>darwin &lt;- sample(darwin, 5000, replace = F)
twain &lt;- sample(twain, 5000, replace = F)
orwell &lt;- sample(orwell, 5000, replace = F)
lovecraft &lt;- sample(lovecraft, 5000, replace = F)
husband &lt;- sample(husband, 5000, replace = F)</code></pre>
<p>We now load the “syuzhet” package and apply the “get_nrc_sentiment” function to the data which performs the Sentiment Analysis.</p>
<pre class="r"><code># load library
library(syuzhet)
# perform sentiment analysis
darwinemo &lt;- get_nrc_sentiment(darwin)
twainemo &lt;- get_nrc_sentiment(twain)
orwellemo &lt;- get_nrc_sentiment(orwell)
lovecraftemo &lt;- get_nrc_sentiment(lovecraft)
husbandemo &lt;- get_nrc_sentiment(husband)
# inspect data
head(darwinemo)</code></pre>
<pre><code>##   anger anticipation disgust fear joy sadness surprise trust negative
## 1     0            0       0    0   0       0        0     0        0
## 2     0            0       0    0   0       0        0     0        0
## 3     0            0       0    0   0       0        0     0        0
## 4     0            0       0    0   0       0        0     0        0
## 5     0            0       0    0   0       0        0     0        0
## 6     0            0       0    0   0       0        0     0        0
##   positive
## 1        0
## 2        0
## 3        0
## 4        0
## 5        0
## 6        0</code></pre>
<p>After performing the Sentiment Analysis, we prepare the data for visualizations</p>
<pre class="r"><code># extract percentages of emotional words
darwinemos &lt;- colSums(darwinemo)/50
twainemos &lt;- colSums(twainemo)/50
orwellemos &lt;- colSums(orwellemo)/50
lovecraftemos &lt;- colSums(lovecraftemo)/50
husbandemos &lt;- colSums(husbandemo)/50
# collapse into a single table
emolit &lt;- data.frame(darwinemos, twainemos, orwellemos, lovecraftemos, husbandemos)
# transpose data
emo &lt;- t(emolit)
# clean row names
rownames(emo) &lt;- gsub(&quot;emos&quot;, &quot;&quot;, rownames(emo))
# inspect data
head(emo)</code></pre>
<pre><code>##           anger anticipation disgust fear  joy sadness surprise trust
## darwin     0.76         1.48    0.44 1.28 1.12    1.32     0.80  2.98
## twain      1.02         2.30    0.80 1.34 1.64    1.46     1.14  2.04
## orwell     1.50         2.02    1.36 2.32 1.90    2.26     0.94  2.72
## lovecraft  1.58         2.00    1.42 2.46 1.20    2.24     1.22  1.76
## husband    2.06         2.36    1.18 2.32 2.18    2.30     1.22  2.34
##           negative positive
## darwin        2.38     4.02
## twain         2.64     3.04
## orwell        3.72     4.48
## lovecraft     4.44     3.10
## husband       4.42     4.42</code></pre>
<pre class="r"><code>#convert into data frame
emo &lt;- as.data.frame(emo)
# add author column
emo$Author &lt;- c(&quot;Darwin&quot;, &quot;Twain&quot;, &quot;Orwell&quot;, &quot;Lovecraft&quot;, &quot;Husband&quot;)
# load library
library(tidyr)
# convert data from wide to long
emol &lt;- gather(emo, Emotion, Score, anger:positive, factor_key=TRUE)
# inspect data
head(emol)</code></pre>
<pre><code>##      Author      Emotion Score
## 1    Darwin        anger  0.76
## 2     Twain        anger  1.02
## 3    Orwell        anger  1.50
## 4 Lovecraft        anger  1.58
## 5   Husband        anger  2.06
## 6    Darwin anticipation  1.48</code></pre>
<p>Based on this table, we can now visualise the relative emotion scores for each book.</p>
<pre class="r"><code># load library
library(ggplot2)
# extract subset
emol2 &lt;- emol %&gt;%
  filter(Emotion != &quot;positive&quot;) %&gt;%
  filter(Emotion != &quot;negative&quot;)
# start plot
ggplot(emol2,                   # plot barplotdatagg1
       aes(Emotion, Score,      # define x- and y-axis
           fill = Author)) +    # define grouping variable
  geom_bar(stat=&quot;identity&quot;,     # determine type of plot
           position=position_dodge()) +  # determine grouping
  scale_fill_manual(values=c(&quot;goldenrod2&quot;, &quot;gray70&quot;, &quot;indianred4&quot;, &quot;grey30&quot;, &quot;lightblue&quot;)) +                 # define colours
  theme_bw()                    # define theme (black and white)</code></pre>
<p><img src="textanalysis_files/figure-html/sa7-1.png" width="672" /></p>
</div>
<div id="entity-extraction" class="section level1">
<h1><span class="header-section-number">11</span> Entity Extraction</h1>
<p>Entity Extraction is a process during which textual elements which have characteristics that are common to proper nouns (locations, people, organizations, etc.) rather than other parts of speech, e.g. non-sentence initial capitalization, are extracted from texts. Retrieving entities is common in automated summarization and in Topic Modelling. Entity extraction can be achieved by simple feature extraction (e.g. extract all non-sentence initial capitalized words) or with the help of training sets. Using training sets, i.e. texts that are annotated for entities and non-entities, achieves better results when dealing with unknown data and data with inconsistent capitalization.</p>
<pre class="r"><code># load libraries
library(NLP)
library(openNLP)
library(openNLPmodels.en)
# load text
orwell &lt;- readLines(&quot;https://slcladal.github.io/data/orwell.txt&quot;)
orwell &lt;- orwell  %&gt;%
  paste(sep = &quot; &quot;, collapse = &quot; &quot;) %&gt;%
  str_replace_all(&quot; {2,}&quot;, &quot; &quot;) %&gt;%
  str_replace_all(&quot;Part 2,.*&quot;, &quot;&quot;)
# convert text into string
orwell = as.String(orwell)
# define annotators
sent_annot = Maxent_Sent_Token_Annotator()
word_annot = Maxent_Word_Token_Annotator()
loc_annot = Maxent_Entity_Annotator(kind = &quot;location&quot;) 
people_annot = Maxent_Entity_Annotator(kind = &quot;person&quot;) 
# start annotation
orwellanno = NLP::annotate(orwell, list(sent_annot, word_annot, 
                                        loc_annot, people_annot))
# extract features
k &lt;- sapply(orwellanno$features, `[[`, &quot;kind&quot;)
# extract locations
orwelllocations = names(table(orwell[orwellanno[k == &quot;location&quot;]]))
# extract people
orwellpeople = names(table(orwell[orwellanno[k == &quot;person&quot;]]))
# inspect extract people
orwellpeople</code></pre>
<pre><code>##  [1] &quot;Adam&quot;                &quot;Ah&quot;                  &quot;Big Brother&quot;        
##  [4] &quot;Byron&quot;               &quot;Comrade Ogilvy&quot;      &quot;Floating Fortresses&quot;
##  [7] &quot;Goldstein&quot;           &quot;Ingsoc.&quot;             &quot;Jews&quot;               
## [10] &quot;Jones&quot;               &quot;Julius Caesar&quot;       &quot;Martin&quot;             
## [13] &quot;Milton&quot;              &quot;Parsons&quot;             &quot;Peace&quot;              
## [16] &quot;Rutherford&quot;          &quot;Saint Sebastian&quot;     &quot;Shakespeare&quot;        
## [19] &quot;Smith&quot;               &quot;St Martin&quot;           &quot;Syme&quot;               
## [22] &quot;Tom&quot;                 &quot;Winston&quot;             &quot;Winston Smith&quot;      
## [25] &quot;Withers&quot;</code></pre>
</div>
<div id="topic-modelling" class="section level1">
<h1><span class="header-section-number">12</span> Topic Modelling</h1>
<p>Topic Modelling is a procedure that allows to extract clusters of key words. These key word clusters can represent topics and the extraction and detection of such key word clusters builds on word frequencies and correlations between word frequencies.</p>
<pre class="r"><code># load data
darwin &lt;- readLines(&quot;https://slcladal.github.io/data/origindarwin.txt&quot;)
twain &lt;- readLines(&quot;https://slcladal.github.io/data/twainhuckfinn.txt&quot;)
orwell &lt;- readLines(&quot;https://slcladal.github.io/data/orwell.txt&quot;)
# clean files 
darwin &lt;- paste(gsub(&quot; {2,}&quot;, &quot; &quot;, darwin), sep = &quot; &quot;, collapse = &quot; &quot;)
twain &lt;- paste(gsub(&quot; {2,}&quot;, &quot;  &quot;, twain), sep = &quot; &quot;, collapse = &quot; &quot;)
orwell &lt;- paste(gsub(&quot; {2,}&quot;, &quot; &quot;, orwell), sep = &quot; &quot;, collapse = &quot; &quot;)
# inspect data
str(orwell)</code></pre>
<pre><code>##  chr &quot;1984 George Orwell Part 1, Chapter 1 It was a bright cold day in April, and the clocks were striking thirteen. &quot;| __truncated__</code></pre>
<p>Now, we create a corpus object and clean the corpus.</p>
<pre class="r"><code># load library
library(tm)
# create corpus object
texts &lt;- Corpus(VectorSource(c(darwin, twain, orwell)))
# create vector with words to remove
extrawords &lt;- c(&quot;the&quot;, &quot;can&quot;, &quot;get&quot;, &quot;got&quot;, &quot;can&quot;, &quot;one&quot;, 
                &quot;dont&quot;, &quot;even&quot;, &quot;may&quot;, &quot;but&quot;, &quot;will&quot;, 
                &quot;much&quot;, &quot;first&quot;, &quot;but&quot;, &quot;see&quot;, &quot;new&quot;, 
                &quot;many&quot;, &quot;less&quot;, &quot;now&quot;, &quot;well&quot;, &quot;like&quot;, 
                &quot;often&quot;, &quot;every&quot;, &quot;said&quot;, &quot;two&quot;)
# load libraries
library(dplyr)
library(stringr)
# clean corpus
textsclean &lt;- texts %&gt;%
  tm_map(removePunctuation) %&gt;%
  tm_map(removeNumbers) %&gt;% 
  tm_map(tolower) %&gt;%
  tm_map(removeWords, stopwords(kind = &quot;en&quot;)) %&gt;%
  tm_map(removeWords, extrawords)</code></pre>
<p>We now create a document term matrix and perform a Linear Discriminant Analysis (LDA). An LDA is a type of classification procedure that is commonly used in machine learning (similar to KNN-Clustering or other classification methods). To obtain even better results, dimensionality reduction procedures such as Principal Component Analysis (PCA) or Multidimensional Scaling (MDS) could be performed prior to applying the LDA ( <a href="https://towardsdatascience.com/linear-discriminant-analysis-lda-101-using-r-6a97217a55a6">see here for an example</a>). We will not perform any dimension reduction here fro the sake of brevity though.</p>
<pre class="r"><code># create DTM
textsdtm &lt;- DocumentTermMatrix(textsclean)
# load library
library(topicmodels)
# perform LDA
textslda &lt;- LDA(textsdtm, k = 3, control = list(seed = 20190712))
textslda</code></pre>
<pre><code>## A LDA_VEM topic model with 3 topics.</code></pre>
<p>We can now inspect which words are particularly associated with which topic.</p>
<pre class="r"><code># load library
library(tidytext)
# convert data into tidy format
textstopics &lt;- tidy(textslda, matrix = &quot;beta&quot;)
textstopics</code></pre>
<pre><code>## # A tibble: 61,596 x 3
##    topic term            beta
##    &lt;int&gt; &lt;chr&gt;          &lt;dbl&gt;
##  1     1 abdomen    4.99e-108
##  2     2 abdomen    2.19e-  5
##  3     3 abdomen    5.34e-163
##  4     1 aberrant   9.46e-108
##  5     2 aberrant   7.66e-  5
##  6     3 aberrant   7.53e-163
##  7     1 aberration 2.96e-108
##  8     2 aberration 2.19e-  5
##  9     3 aberration 5.88e-163
## 10     1 abhorrent  2.18e-108
## # ... with 61,586 more rows</code></pre>
<p>The beta values show how strongly a given term correlates with one of the topics. For example, the term “abdomen”, is very unlikely associated with topic 1 or 3 as the beta values are very low (4.988e-108 and 5.344e-163). In contrast, the beta value for topic 2 is 2.189e-5 and thus much higher than the beta values for topic 1 and 3. Therefore, the term “abdomen” is most likely indicative of or associated with topic 2.</p>
<p>In a next step, we visualize the keyterms for each topic to check if the topics happen to reflect the monograph themes.</p>
<pre class="r"><code># load libraries
library(ggplot2)
library(dplyr)
# extract top words
textstopicstop &lt;- textstopics %&gt;%
  group_by(topic) %&gt;%
  top_n(15, beta) %&gt;%
  ungroup() %&gt;%
  arrange(term, -beta)
# create plots
textstopicstop %&gt;%
  mutate(term = reorder(term, beta)) %&gt;%
  ggplot(aes(term, beta, fill = factor(topic))) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~ topic, scales = &quot;free&quot;) +
  coord_flip()</code></pre>
<p><img src="textanalysis_files/figure-html/tm5-1.png" width="672" /></p>
<p>The topic modelling does, in fact, reflect the narrative topics of the three monographs with the first topic representing Orwell’s “1984”, the second topic representing Darwin’s “On the origin of species”, and the third topic representing Twain’s “Adventures of Huckleberry Finn”.</p>
<p>Topic Models can be refined and made more meaningful in various ways. For instance, the topic model shown here could be improved by splitting the monographs into chapters and running the analysis on the individual chapters rather than the entire monograph. Also, a very interesting application of Topic Models would be to investigate changes in topics over time which is dealt with in the tutorial that delves deeper into topic modelling.</p>
</div>
<div id="network-analysis" class="section level1">
<h1><span class="header-section-number">13</span> Network Analysis</h1>
<p>Network analysis is not really a type of analysis but rather a method for visualization that can be used to represent various types of data. However, because network analyses are widely used and a very useful procedure, we will introduce the basics of network analysis here.</p>
<p>The issue we want to investigate here relates to networks of personas in Shakespeare’s “Romeo and Juliet”.</p>
<pre class="r"><code># load libraries
library(gutenbergr)
library(dplyr)
# load data
romeo &lt;- gutenberg_works(title == &quot;Romeo and Juliet&quot;) %&gt;%
  gutenberg_download(meta_fields = &quot;title&quot;)
# inspect data
romeo</code></pre>
<pre><code>## # A tibble: 5,268 x 3
##    gutenberg_id text                       title           
##           &lt;int&gt; &lt;chr&gt;                      &lt;chr&gt;           
##  1         1513 ROMEO AND JULIET           Romeo and Juliet
##  2         1513 &quot;&quot;                         Romeo and Juliet
##  3         1513 by William Shakespeare     Romeo and Juliet
##  4         1513 &quot;&quot;                         Romeo and Juliet
##  5         1513 &quot;&quot;                         Romeo and Juliet
##  6         1513 &quot;&quot;                         Romeo and Juliet
##  7         1513 &quot;&quot;                         Romeo and Juliet
##  8         1513 PERSONS REPRESENTED        Romeo and Juliet
##  9         1513 &quot;&quot;                         Romeo and Juliet
## 10         1513 Escalus, Prince of Verona. Romeo and Juliet
## # ... with 5,258 more rows</code></pre>
<p>Now that we have loaded the data, we need to split the data into scenes. Scenes during which personas leave or enter will have to be split too so that we arrive at a table that contains the personas that are present during a subscene.</p>
<pre class="r"><code># load library
library(stringr)
# load split
romeoscenes &lt;- romeo %&gt;%
  select(text) %&gt;%
  as.vector() %&gt;%
  str_replace_all(fixed(&quot;\&quot;&quot;), &quot;&quot;) %&gt;%
  str_replace_all(fixed(&quot;\n&quot;), &quot;&quot;) %&gt;%
  paste(collapse = &quot; &quot;) %&gt;%
  str_replace_all(&quot;(Scene )&quot;, &quot;qwertz\\1&quot;) %&gt;%
  strsplit(&quot;qwertz&quot;) %&gt;%
  unlist()
# inspect data
str(romeoscenes[2])</code></pre>
<pre><code>##  chr &quot;Scene I. A public place., , [Enter Sampson and Gregory armed with swords and bucklers.], , Sampson., Gregory, o&quot;| __truncated__</code></pre>
<p>Now we extract the persons that are present in each scene.</p>
<pre class="r"><code># load library
library(stringr)
# extract persons
romeopersonas &lt;- romeoscenes %&gt;%
  str_match_all(&quot; , [A-Z][a-z]{2,} {0,1}[A-Z]{0,1}[a-z]{0,}\\.&quot;)
# inspect data
str(romeopersonas[1:5])</code></pre>
<pre><code>## List of 5
##  $ : chr [1, 1] &quot; , Chor.&quot;
##  $ : chr [1:93, 1] &quot; , Sampson.&quot; &quot; , Gregory.&quot; &quot; , Sampson.&quot; &quot; , Gregory.&quot; ...
##  $ : chr [1:29, 1] &quot; , Capulet.&quot; &quot; , Paris.&quot; &quot; , Capulet.&quot; &quot; , Paris.&quot; ...
##  $ : chr [1:29, 1] &quot; , Lady Capulet.&quot; &quot; , Nurse.&quot; &quot; , Juliet.&quot; &quot; , Nurse.&quot; ...
##  $ : chr [1:28, 1] &quot; , Romeo.&quot; &quot; , Benvolio.&quot; &quot; , Romeo.&quot; &quot; , Mercutio.&quot; ...</code></pre>
<p>We now clean and vectorize the data.</p>
<pre class="r"><code># extract personas per scene
personas &lt;- sapply(romeopersonas, function(x){
  x &lt;- unlist(x)
  x &lt;- gsub(&quot;,&quot;, &quot;&quot;, x)
  x &lt;- gsub(&quot;\\.&quot;, &quot;&quot;, x)
  x &lt;- gsub(&quot; &quot;, &quot;&quot;, x)
  x &lt;- unique(x)
  x &lt;- as.vector(x)
  x &lt;- paste(x, collapse = &quot; &quot;)
  x &lt;- gsub(&quot; ActV&quot;, &quot;&quot;, x)
  x &lt;- gsub(&quot; Page&quot;, &quot;&quot;, x)
})
# inspect data
personas</code></pre>
<pre><code>##  [1] &quot;Chor&quot;                                                                                          
##  [2] &quot;Sampson Gregory Abraham Benvolio Tybalt Capulet LadyCapulet Montague Prince LadyMontague Romeo&quot;
##  [3] &quot;Capulet Paris Servant Benvolio Romeo&quot;                                                          
##  [4] &quot;LadyCapulet Nurse Juliet Servant&quot;                                                              
##  [5] &quot;Romeo Benvolio Mercutio&quot;                                                                       
##  [6] &quot;Capulet Romeo Servant Tybalt Juliet Nurse Benvolio Chorus&quot;                                     
##  [7] &quot;Romeo Benvolio Mercutio&quot;                                                                       
##  [8] &quot;Romeo Juliet Nurse&quot;                                                                            
##  [9] &quot;Friar Romeo&quot;                                                                                   
## [10] &quot;Mercutio Benvolio Romeo Nurse Peter&quot;                                                           
## [11] &quot;Juliet Nurse&quot;                                                                                  
## [12] &quot;Friar Romeo Juliet&quot;                                                                            
## [13] &quot;Benvolio Mercutio Tybalt Romeo Prince LadyCapulet Montague&quot;                                    
## [14] &quot;Juliet Nurse&quot;                                                                                  
## [15] &quot;Friar Romeo Nurse&quot;                                                                             
## [16] &quot;Capulet Paris LadyCapulet&quot;                                                                     
## [17] &quot;Juliet Romeo Nurse LadyCapulet Capulet&quot;                                                        
## [18] &quot;Friar Paris Juliet&quot;                                                                            
## [19] &quot;Capulet Nurse Juliet LadyCapulet&quot;                                                              
## [20] &quot;Juliet LadyCapulet&quot;                                                                            
## [21] &quot;LadyCapulet Nurse Capulet&quot;                                                                     
## [22] &quot;Nurse LadyCapulet Capulet Friar Paris Peter&quot;                                                   
## [23] &quot;Romeo Balthasar Apothecary&quot;                                                                    
## [24] &quot;FriarJohn FriarLawrence&quot;                                                                       
## [25] &quot;Paris Romeo Balthasar Friar Juliet Prince Capulet LadyCapulet Montague Boy&quot;</code></pre>
<p>We will edlete the first element as it only contains the chor but none of the main personas.</p>
<pre class="r"><code># remove first elements
personas &lt;- personas[2:length(personas)]
str(personas)</code></pre>
<pre><code>##  chr [1:24] &quot;Sampson Gregory Abraham Benvolio Tybalt Capulet LadyCapulet Montague Prince LadyMontague Romeo&quot; ...</code></pre>
<p>The vectors must now be transformed into a sparse matrix.</p>
<pre class="r"><code># load library
library(tm)
# create corpus
corpus &lt;- Corpus(VectorSource(personas))
# create document term matrix
scenepersonas &lt;- DocumentTermMatrix(corpus) 
# load library
library(Matrix)
# convert dtm into sparse matrix
rnjdtm &lt;- sparseMatrix(i = scenepersonas$i, j = scenepersonas$j, 
                           x = scenepersonas$v, 
                           dims = c(scenepersonas$nrow,
                                    scenepersonas$ncol),
                           dimnames = dimnames(scenepersonas))
# calculate cooccurrence counts
coocurrence &lt;- t(rnjdtm) %*% rnjdtm
# convert into matrix
romeom &lt;- as.matrix(coocurrence)
# inspect data
head(romeom)</code></pre>
<pre><code>##              abraham benvolio capulet gregory ladycapulet ladymontague
## abraham            1        1       1       1           1            1
## benvolio           1        7       3       1           2            1
## capulet            1        3       9       1           7            1
## gregory            1        1       1       1           1            1
## ladycapulet        1        2       7       1          10            1
## ladymontague       1        1       1       1           1            1
##              montague prince romeo sampson tybalt paris servant juliet
## abraham             1      1     1       1      1     0       0      0
## benvolio            2      2     7       1      3     1       2      1
## capulet             2      2     5       1      2     4       2      4
## gregory             1      1     1       1      1     0       0      0
## ladycapulet         3      3     4       1      2     3       1      5
## ladymontague        1      1     1       1      1     0       0      0
##              nurse mercutio chorus friar peter apothecary balthasar
## abraham          0        0      0     0     0          0         0
## benvolio         2        4      1     0     1          0         0
## capulet          5        0      1     2     1          0         1
## gregory          0        0      0     0     0          0         0
## ladycapulet      5        1      0     2     1          0         1
## ladymontague     0        0      0     0     0          0         0
##              friarjohn friarlawrence boy
## abraham              0             0   0
## benvolio             0             0   0
## capulet              0             0   1
## gregory              0             0   0
## ladycapulet          0             0   1
## ladymontague         0             0   0</code></pre>
<p>In order to represent the data as a network, the matrix has to be transformed into a data frame that contains the characters, the perosonas they co-occur with, and the frequency of these co-occurrences as seperate columns.</p>
<pre class="r"><code># create cooccurence table
persona1 &lt;- rep(colnames(romeom), each = nrow(romeom))
persona2 &lt;- rep(rownames(romeom), ncol(romeom))
freq &lt;- as.vector(unlist(romeom))
# combine into data frame
dc &lt;- data.frame(persona1, persona2, freq)
# remove cooccurence with oneself
df &lt;- dc %&gt;%
  filter(persona1 != persona2)
# inspect data
head(df)</code></pre>
<pre><code>##   persona1     persona2 freq
## 1  abraham     benvolio    1
## 2  abraham      capulet    1
## 3  abraham      gregory    1
## 4  abraham  ladycapulet    1
## 5  abraham ladymontague    1
## 6  abraham     montague    1</code></pre>
<p>Now, that the data is present in a sparse matrix format, it can be displayed as a network.</p>
<pre class="r"><code># load library 
library(igraph)
# remove infrequent cooccurences and create graph object
bigram_graph &lt;- df %&gt;%
  graph_from_data_frame()
# load library
library(ggraph)
library(grid)
# define arrow type
a &lt;- grid::arrow(type = &quot;open&quot;, length = unit(.15, &quot;cm&quot;))
# create plot
ggraph(bigram_graph, layout = &quot;auto&quot;) +
  geom_edge_link(aes(edge_alpha = freq), show.legend = FALSE,
                 arrow = a, end_cap = circle(1, &#39;inches&#39;)) +
  geom_node_point(color = &quot;lightblue&quot;, size = 3) +
  geom_node_text(aes(label = name), vjust = 1, hjust = 1) +
  theme_void()</code></pre>
<p><img src="textanalysis_files/figure-html/na9-1.png" width="672" /></p>
<p>Such network graphs can be modified to highlight certain aspects of the interactions, e.g. we could have the size of lightblue dots represent the frequency that a given character occurs. A more in-depth example of a network analysis is shown in the tutorial on “Network Analysis”.</p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
