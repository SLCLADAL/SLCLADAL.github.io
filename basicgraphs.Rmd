---
title: "Simple Graphs"
author: "UQ SLC Digital Team"
date: "2 Dezember 2018"
output: html_document
bibliography: bibliography.bib
---

## Introduction

This section discusses how data can be visualized and what needs to be kept in mind when visualizing data, e.g. axes labeling, and it exemplifies different types of graphs (scatter plot, line graphs, bar-charts, histograms, pie charts, box-plot). In addition, the pros and cons of different types of graphs are discussed and the steps and procedures to set up graphs are shown so that you can re-create the graphs at home. The practical part also focuses on potential probelms you may encounter when setting up a graph. The graphs are plotted in R as it is a very flexible tool for visualization and offers more control over the distinct layers of plots.

There is a multitude of different ways to visualize data and thus we focus only on the most common types of visualization in this chapter. Each type of plot is created `R` as it is extremely flexible and powerful when it comes to graphics.  

## Graphics with R
Before turning to the practical part, a few words on different frameworks fro creating graphics in `R` are in order. There are three basic frameworks in which to create graphics in `R`. The basic framework, the lattice framework, and the ggplot framework. The basic framework is the oldest and is included in the `base`-package that is automatically activated when entering `R`. 

### The `basic` environment
The idea behind the `basic` environment is that the creation of graphics is seen in analogy to a painter who paints on an empty canvass. Each line or element is added to the graph consequetively which oftentimes leads to code that is very comprehensible but aso very long.

### The `lattice` environment
The `lattice` enviroment was a follow-up to the `base`-package and it complemented it insofar as it made it much easier to display various variables and variable levels simultaneously. The philosophy of the `lattice`-package is quite different from the philosophy in the `base`-package: Whereas everything had to be specified in `base`, the graphs cerated in the `lattice`environment require only very little code but are therefore very easily cerated when one is satisfied with the design but vey labor intensive when it comes to customizeing graphs. Howvere, the `lattice`package is very handy when summarizing relationships between multiple variable and variable levels.

### The `ggplot` environment
The `ggplot` environment was written by Hadley Wickham and it combines the positive aspects of both the `base` and the `lattice` package. It was first publicized in the `gplot`and `ggplot1` packages but the latter was soon repackaged and improved in the now most widely used package for data visualization: the ggplot2` package. The `ggplot`-environemt implements a philosophy of graphic design described in builds on *The Grammar of Graphics* by Leland Wilkinson ([@wilkinson2006grammar]).

The philosophy of `ggplot2`is to consider graphics as consisting out of basic elements (called aesthetics and they include, for instance, the data set to be plotted and the axes) and layers that overlayed onto the aestethics. The idea of the `ggplot2`package can eb summarized as taking "care of many of the fiddly details that make plotting a hassle (like drawing legends) as well as providing a powerful model of graphics that makes it easy to produce complex multi-layered graphics."

In the following, the graphs are initially created in the `base`environment while `lattice` and `ggplot` graphs, if approprite, are shown afer the basic display.

## Data
Before turning to the graphs themselves, we will briefly look at the structures of the data sets to what we are working with. In this chapter, we will not use language data but inbuild data sets that are provided by `R` and already loaded when entering `R`. The data sets are called `iris` and `mtcars`. The `iris` data set contains information about "measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica" (cf. [@becker1988s]). In a first step, we attach the `iris` data so that we only need to write the variable names without having to repeat the name of the data set. Then, we inspect the structure of the `iris` data using the `str()` command.

```{r eval=T}
# attach iris
attach(iris)
# inspect  iris data
str(iris)
```

The `iris` data contains four numeric variables which provide the values for sepal length and width as well as petal length and width. In addition, the data contains a factor which denotes the flower species. We will now turn to creating the graphs.

## Scatter plot

The first, and simplest graph, is a so-called "scatterplot". Scatterplots are used when the graph is set up to display the relationship between two numeric variables. We will start off with creating a scatter plot in the `base` environment, then in the `lattice` package and finally in the `ggplot` environment.

### Scatter plot in `base`  
The most fundamental function to creta eplots in the `base` environment is to use the general `plot` function. Here, we use that function to cerate a simple scatter plot.

```{r echo = F, results = 'asis'}
# create scatterplot in base
plot(Sepal.Length ~ Sepal.Width, type = "p", data = iris, ylab = "Sepal Length", xlab = "Sepal Width", main = "plot type 'p' (points)")
```


Let us go over the command. The first part of the call is `plot` which is the function for plotting data in the `base` package. In the round brackets are the arguments in which we specify what the plot should look like. The "Sepal.Length ~ Sepal.Width" part tells `R` which variables should be displayed and the "type = "p"" part tells `R` which type of plot we want ("p" stands for points, "l", for lines, "b" for both lines and points). The part "data = iris" tells `R` which data set to take the data from, and "ylab = "Sepal Length"" and "xlab = "Sepal Width"" informs `R`about the axes labels. The part "main = "plot type 'p' (points)" informs `R` about what we want as the main title of the plot. 

In a next step, we will add a regression line to the scatterplot (in the first case a linear and in the second case a smoothed regression line).

```{r echo = F, results = 'asis'}
# recreate plot
plot(Sepal.Length ~ Sepal.Width, type = "p", data = iris, ylab = "Sepal Length", xlab = "Sepal Width", main = "plot type 'p' (points)")
# add regression line
abline(lm(Sepal.Length ~ Sepal.Width), col="red") # regression line (y~x)
# add smoothed line
lines(lowess(Sepal.Width, Sepal.Length), col="blue") # lowess line (x,y)
```

### Scatter plot in `lattice`

In order to be able to plot data using the `lattice` package, we need to install and activate it first.
 
```{r echo = F}
# install and activate lattice package (remove # to activate code)
#install.packages("lattice") 
library(lattice)
```

After the `lattice` package is loaded, we can cerate a first simple scatter plot using the `xyplot` function form the `lattice` package.

```{r echo = F, results = 'asis'}
# create scatterplot in lattice
xyplot(Sepal.Length ~ Sepal.Width, ylab = "Sepal Length", xlab = "Sepal Width")
```

Since the `lattice` package was cerated to plot multiple relationships with a single call, we will now make use of that feature and plot multiple relationships at once. In addition, we will add a grid to the plot to improve comparability of adat points within the graph.

```{r echo = F, results = 'asis'}
# create scatterplots with in lattice
xyplot(Sepal.Length ~ Sepal.Width | Species, ylab = "Sepal Length", xlab = "Sepal Width", grid = TRUE)
```

The only new code in the chunk above is the "| Species" part. This part means that the relationship between Sepal.Length and Sepal.Width should be displayed by Species. So the |-symbol can be translated into "by". The splitting of the plot into different oanels for Species is then done automatically. Next, we will use the `ggplot2`-package to create a scatter plot 

### Scatter plot in `ggplot2`

A with the `lattice`-package, we need to install and activate the `ggplot2` before we are able to plot data using the `ggplot2` package.

```{r echo = F}
# install and activate ggplot2 package (remove # to activate code)
#install.packages("ggplot2")
library(ggplot2)
```

Next, we create a very basic scatterplot in `ggplot2`. The advantages of using `ggplot2` will be shown below.

```{r echo = F, results = 'asis'}
ggplot(iris, aes(x=Sepal.Length, y= Sepal.Width)) +
  geom_point()
```

Let's go over the code above. The function call for plotting in `ggplot2` is simply `ggplot`. This function takes the data set as its first argument and then requires aesthetics. The aesthetics are defined within the `ggplot` function as thearguments of `aes`. The `aes` function takes the axes as the arguments (in the current case). Then, we need to define the type of plot that we want. As we want a scatter plot with points, we add the `geom_point()` function without any arguments (as we do not want to specify the size, color, and shape of the points just yet).

The advantage of `ggplot2` is that is really easy to modify the plot by adding new layers and to change the basic outllok bymodifying the theme which is waht we will do in the code below.

```{r echo = F, results = 'asis'}
ggplot(iris, aes(x=Sepal.Length, y= Sepal.Width, color = Species)) +
  geom_point() +
  theme_bw()
```

```{r echo = F, results = 'asis'}
ggplot(iris, aes(x=Sepal.Length, y= Sepal.Width, color = Species)) +
  geom_point() +
  scale_color_manual(values = c('lightgray', 'darkgrey','gold')) +
#  geom_text(label=c("+", "x", "o")) +
  theme_bw()
```


Next, we will create a line chart. Line charts are used when you have a series of points (e.g. mean values) for categorical variables.

\begin{lstlisting}
# Linechart
female <- c(0.9, 0.5, 0.4); male <- c(1.6, 0.7, 0.2)
plot(female, type = "o", ylim = c(0, 3), ylab = "Rel. Frequency", xlab = "Stages", axes = F, col = "red")
lines(male, type = "o", lty = 2, pch = 0, col = "blue")
axis(1, at = 1:3, lab = c("Stage 1","Stage 2","Stage 3"))
axis(2, at = seq(0, 3, .5), las = 1, lab = seq(0, 3, .5))
box()
# Add legend
legend("topright", inset = .05, c("female", "male"),
horiz = F, lty = c(1, 2))
# create grid in plot
grid()
\end{lstlisting}

\begin{center}
\includegraphics[width=.8\linewidth]{images/lineplot02.png}
\end{center}

Simple Bar Plot

\begin{lstlisting}
counts <- table(mtcars$gear)
barplot(counts, main="Car Distribution",
xlab="Number of Gears", ylim = c(0,20))
\end{lstlisting}

\begin{center}
\includegraphics[width=.8\linewidth]{images/barplot01.png}
\end{center}

\begin{lstlisting}
# Barplot
# Simple Bar Plot
barplot(counts, main="Car Distribution", horiz = T,
xlab="Number of Gears", col = c("grey30", "grey50", "grey70"), xlim = c(0,20))
box()
\end{lstlisting}

\begin{center}
\includegraphics[width=.8\linewidth]{images/barplot02.png}
\end{center}

\begin{center}
\texttt{DO NOT USE PIECHARTS!}
\end{center}

\begin{lstlisting}
# Piechart
slices <- c(10, 12, 4, 16, 8)
lbls <- c("US", "UK", "Australia", "Germany", "France")
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) \# add percents to labels
lbls <- paste(lbls,"\%",sep="") \# add \% to labels
pie(slices,labels = lbls, col=rainbow(length(lbls)),
main="Pie Chart of Countries")
\end{lstlisting}

\begin{center}
\includegraphics[width=4cm]{images/piechart01.png}
\includegraphics[width=4cm]{images/barplot03.png}
\end{center}

\begin{lstlisting}
# Boxplot
# Simple Bar Plot
barplot(counts, main="Car Distribution", horiz = T,
xlab="Number of Gears", col = c("grey30", "grey50", "grey70"), xlim = c(0,20))
box()
\end{lstlisting}

\begin{center}
\includegraphics[width=4cm]{images/barplot02.png}
\end{center}

\begin{lstlisting}
# Boxplot of MPG by Car Cylinders
boxplot(mpg~cyl,data=mtcars, main="Car Milage Data",
xlab="Number of Cylinders", ylab="Miles Per Gallon", notch = T, col = c("lightgrey", "lightblue", "lightgreen"))
\end{lstlisting}

\begin{center}
\includegraphics[width=6cm]{images/boxplot01.png}
\end{center}

\begin{lstlisting}
# Mosaicplot
library(vcd)
HairEyeColor <- HairEyeColor[c(1:2, 4), c(1:2, 4), 1]
mosaic(HairEyeColor, shade=TRUE, legend=TRUE)
\end{lstlisting}

\begin{center}
\includegraphics[width=6cm]{images/mosaicplot01.png}
\end{center}

\begin{lstlisting}
# Associationplot
library(vcd)
HairEyeColor <- HairEyeColor[c(1:2, 4), c(1:2, 4), 1]
assoc(HairEyeColor, shade=TRUE)
\end{lstlisting}

\begin{center}
\includegraphics[width=6cm]{images/assocplot01.png}
\end{center}

\subsection{Wordclouds}
Word clouds visualize word frequencies of either single corpora or they visualize different corpora. Although word clouds are not really used in academic linguistics, they are a neat way to display the themes - which may be thought of as the semantic content - of corpora.
To exemplify how to use word clouds, we are going to have a look at the election programs (Wahlkampfprogramme) of German political parties for the Bundestag elections 2013.

Prepare data by removing all lists from the current work space and installing packages we need or which may be useful
\begin{lstlisting}
rm(list=ls(all=T))

# (to activate just delete the #)
#install.packages("tm")
#install.packages("wordcloud")
#install.packages("Rstem")
#install.packages("stringr")
#install.packages("SnowballC")

# Initiate the packages
library(tm)
library(wordcloud)
library(Rstem)
library(stringr)
library(SnowballC)
\end{lstlisting}

Read in data

\begin{lstlisting}
corp <- Corpus(DirSource("C:\\Corpora\\original versions\\Wahlkampfprogramme Bundestagswahl 2013\\corpus"), readerControl = list(language = "german")) #specifies the exact folder where my text file(s) is for analysis with tm.

corp <- Corpus(VectorSource(corp)) # Create a corpus from the vectors
#corp <- tm_map(corp, stemDocument, language = "german") # stem words (inactive because I want intakt words)
corp <- tm_map(corp, removePunctuation) # remove punctuation
corp <- tm_map(corp, tolower) # convert all words to lower case
corp <- tm_map(corp, removeNumbers) # remove all numerals
corp <- tm_map(corp, function(x)removeWords(x, stopwords("german"))) # remove grammatical words such as "ein", "ist", "war", etc.

corp <- Corpus(VectorSource(corp)) # convert vectors back into a corpus

# Create a term document matrix
term.matrix <- TermDocumentMatrix(corp) # crate a term document matrix
term.matrix <- removeSparseTerms(term.matrix, 0.5) # remove infrequent words
term.matrix <- as.matrix(term.matrix)
colnames(term.matrix) <- c("CDU/CSU", "FDP", "Gruene", "Die Linke", "SPD") # add column labels to tdm
# clean row names

# normalize absolute frequencies: convert absolute frequencies
# to relative freqeuncies (per 1,000 words)
#colSums(term.matrix)
term.matrix[, 1] <- as.vector(unlist(sapply(term.matrix[, 1], function(x) round(x/colSums(term.matrix)[1]*1000, 0) )))
term.matrix[, 2] <- as.vector(unlist(sapply(term.matrix[, 2], function(x) round(x/colSums(term.matrix)[2]*1000, 0) )))
term.matrix[, 3] <- as.vector(unlist(sapply(term.matrix[, 3], function(x) round(x/colSums(term.matrix)[3]*1000, 0) )))
term.matrix[, 4] <- as.vector(unlist(sapply(term.matrix[, 4], function(x) round(x/colSums(term.matrix)[4]*1000, 0) )))
term.matrix[, 5] <- as.vector(unlist(sapply(term.matrix[, 5], function(x) round(x/colSums(term.matrix)[5]*1000, 0) )))
#colSums(term.matrix)

# Create word clouds
#wordcloud(corp, max.words = 100, colors = brewer.pal(6, "Dark2"), random.order = FALSE)
comparison.cloud(term.matrix, max.words = 100, random.order = FALSE, colors = brewer.pal(8, "Dark2"))
#commonality.cloud(term.matrix, max.words = 100, random.order = FALSE)
\end{lstlisting}

\begin{center}
\includegraphics[width=\textwidth]{images/ComparativeWordcloud.png}
%\caption{Comparative word cloud showing distinctive words in the election programms of German political parties for the Bundestag election 2013.}
\end{center}

At first I thought that word clouds are simply a fancy but not very helpful way to inspect language data but I have to admit that word clouds really surprised me as they do appear to possess potential to offer an idea of what groups of people are talking about.

The comparative word cloud shows that the \textbf{FDP} stresses concepts like "wettbewerb", "freiheit", "chancen", "liberal" thereby stressing their liberal outlook (they didn't make it and didn't deserve it by the way - just my opinion).
\textbf{Die Grünen} support every nonsense as they are "für" everything and relied more on emphasizing "frauen", "zukunft", and "teilhabe" which is in line with their feel-good philosophy.
\textbf{Die Linke} rallied on about what we has to be done ("müssen"), and used words like "sozial", "beschäftigten", and "öffentlich" a lot showing their emphasis on economic issues.
The social democrats (\textbf{SPD}) addressed topics like "kommunen", "arbeit", "gesellschaft", "bildung", and "gerechtigkeit" - so they essentially used their typical buzz words (just sayin').
Finally, the \textbf{CDU/CSU} mentioned "ländlich", "wohlstand", "unser*, "and "weiterhin" to suggest that they will just continue with whatever nothing that hve been doing over the past years.

In conclusion, I honestly didn't think that I would get meaningful results but the comparative word cloud does a rather good job at that. So that was it on word clouds in R.
