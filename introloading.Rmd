---
title: "Loading and Exporting Data"
author: "Martin Schweinberger"
date: "2 Dezember 2018"
output: html_document
---

\pagebreak\section{Daten bearbeiten mit R}
Im Folgenden werden wir in aller Kürze behandeln, wie sie Daten in \verb!R! importieren und, anschließend, Ergebnisse aus \verb!R! exportieren können.

\subsection{Workspace festlegen}
Es ist sinnvoll zu Beginn einer jeden Sitzung den \textquote{Workspace} festzulegen. Hiermit meint man, dass man den Pfad zu einem Ordner angibt, der als Standardspeicherort dient, sodass man nur angeben muss, welches Objekt man speichern oder aus dem Ordner laden will, ohne dass man immer wieder den gesamten Pfad angeben muss. Dieser Workspace ist individuell verschieden und muss vom jeweiligen User selber ermittelt und angegeben werden. Im gegenwärtigen Fall legen wir den Ordner, der die Materialien für dieses Buch enthält fest. Ich gebe beispielhaft meinen eignen Speicherort an, auch wenn Sie diesen Pfad anpassen müssen, sodass er zu Ihrem Computer passt. Anschließend lasse ich \verb!R! den Pfad zum Workspace anzeigen.\\[.2cm]
\begin{lstlisting}
# Workspeace festlegen
setwd("E:\\StatisticsForLinguists")
# Workspace anzeigen
getwd()
\end{lstlisting}
Von nun an müssen wir nicht mehr den gesamten Pfad zu den Dateien angeben, sondern nur noch den Namen des Objekts, dass wir laden wollen.

\subsection{Daten importieren}
Dieses Buch ist keine Einführung in \verb!R!, d.h. wir werden nur die aller notwendigsten Befehle durchgehen. Diese Befehle benötigen Sie, um Daten zu importieren, Daten zu exportieren oder um statistische Tests durchzuführen. Wir werden zuerst den Befehl anschauen, den Sie nutzen um Daten zu importieren. Sie importieren Daten in \verb!R!, sodass \verb!R! diese Daten dann zur Verfügung stehen und sie in \verb!R! bearbeitet werden können. Am einfachsten ist es, wenn Sie die Daten interaktiv importieren, d.h. \verb!R! öffnet ein Navigationsfenster und Sie suchen dann in diesem Fenster nach den Daten. Um interaktiv eine Tap-Stopp-separierte .txt Datei zu öffnen, müssen sie folgenden Befehl in R eingeben: \\[.2cm]
\begin{lstlisting}
mydata <- read.table(choose.files(), header = T, sep = "\t", quote = "", comment.char = "")
\end{lstlisting}
Der Befehl (oder die Funktion um präzise zu sein) beinhaltet eine Reihe von Argumenten, die wir hier kurz durchsprechen sollten. Um Hilfe zu Funktionen zu bekommen geben Sei den Befehl \verb!?Packetname! in \verb!R! ein (wobei anstatt der Sequenz \verb!Packetname! natürlich der Name der Funktion stehen muss). Nun zu unserer Funktion: Zuerst definieren wir ein Objekt, \verb!mydata!, dem wir das Resultat der Funktion \verb!read.table! mit der Sequenz \verb!<-! zuweisen. Nun definieren wir die Funktion \verb!read.table!. Diese Funktion benötigt die folgenden Argumente: \verb!choose.files()!, \verb!header!, \verb!sep!, \verb!quote!, and \verb!comment.char!. \verb!choose.files()! sagt \verb!R!, dass wir die Datei interaktiv mit einem Browser ansteuern. \verb!choose.files()! kann auch durch den exakten Pfad zu der Datei ersetzt werden (z.B. \verb!"C:\\03-MyProjects\\03RorLinguists/testdata1.txt"!). In diesem Fall liest \verb!R! die Datei direkt aus der angegebenen Quelle ein. Wenn der direkte Pfad angegeben wird, dann müssen doppelte Backslashes anstatt einfacher Backslashes oder Forwardslashes für Direktorien, aber einfache Forwardslashes für individuelle Dateien gesetzt werden. Das Argument \verb!header! ist nötig, um anzugeben, ob die Tabelle Überschriften hat oder nicht. Im Fall das die Daten Überschriften haben, setzt man \verb!header=T!.

Das Argument \verb!sep! ist sehr wichtig, da es angibt, wie die Datenpunkte in der angesteuerten Datei voneinander getrennt sind. In den meisten Fällen werden die Datenpunkte Tab-separiert sein, aber es gibt auch Komma-separierte Dateien (.csv).

Das \verb!"\t"! zeigt an, dass die Datenpunkte Tab-separiert sind, wohingegen \verb!sep = " "! anzeigen würde, dass die Datenpunkte durch Leerzeichen separiert sind und \verb!sep = ","! anzeigen würde, dass die Datenpunkte durch Kommata separiert sind. Das Argument \verb!quote! informiert \verb!R!, dass bestimmte Zeichen Zitate abgrenzen. Das Argument \verb!comment.char! informiert \verb!R!, dass bestimmte Zeichen nicht als normale Zeichen eingelesen werden sollen, sondern Programmierkommentare sind.

Um Tabellen direkt aus Microsoft Excel speadsheets einlesen zu können, müssen Sie zuerst das Paket \verb!xlsx! installieren und aktivieren. Um dieses Paket zu installieren geben Sie den Befehl \verb!install.package("xlsx")! ein und drücken Sie auf \verb!Enter!). Das Paket \verb!xlsx! wird durch den Befehl \verb!library(xlsx)! aktiviert.

\begin{lstlisting}
install.package("xlsx")
library(xlsx)
# pfad festlegen
path <- "testdata1.xlsx"
# daten einlesen
#mydataxlsx <- read.xlsx(path, 1)
mydataxlsx <- read.xlsx(choose.files(), 1)
\end{lstlisting}

Um sich die geladenen Daten anschauen geben Sie den Names des Objekts an, das die Daten enthält. In unserem Fall haben wir das Objekt \verb!mydata! genannt. Geben Sie also \verb!mydata! in die \verb!R! GUI ein, so zeigt Ihnen \verb!R! die geladenen Daten. Mit \verb!str(mydata)! zeigt Ihnen \verb!R! die Struktur Ihres Datensatzes an. Der Befehl \verb!head(mydata)! gibt die ersten sechs Zeilen oder Elemente eines Datenobjekts aus.

\subsection{Daten exportieren}
Im Folgenden geht es darum, wie Daten aus \verb!R! heraus auf Ihrem Rechner gespeichert werden können. Die geläufigste Funktion, um eine Tab-separierte .txt Datei auf Ihrem Rechner zu speichern, ist \verb!write.table!. Diese Funktion benötigt folgende Argumente: Bei dem ersten Argument \verb!file! handelt es sich um das Objekt, dass gespeichert werden soll. \verb!file! muss nicht ausgeschrieben werden, ist aber zuerst zu nennen. Bei dem zweiten Argument \verb!path! handelt es sich um die Angabe, wo \verb!R! die Datei speichern soll. Da wir den Workspace festgelegt ahben, müssen wir \verb!R! nur mitteilen, welchen Namen wir dem zu speichernden Objekt geben wollen. Auch hier muss das Argument nicht genannt werden. Die folgender Argumente, \verb!sep!, \verb!col.names! und \verb!row.names! handelt es sich um das Trennzeichen (entweder Tab, Komma oder Leerzeichen), und Angaben darüber, ob in dem Objekt Zeilen bzw. Spaltennamen vorliegen.

\begin{lstlisting}
# pfad bestimmen
outpath <- "data01.txt"
# daten auf pc speichern
write.table(file = mydata, path = outpath, sep = "\t", col.names = TRUE, row.names = F,quote = F)
\end{lstlisting}

Um daten direkt als eine Microsoft Excel Datei zu speichern müssen Sie zuerst das Packet \verb!xlsx! aktivieren and then apply the \verb!write.xlsx! command:

\begin{lstlisting}
library(xlsx)
write.xlsx(mydata, "C:\\MyProjects\\StatzForLinguists/testdata.xlsx")
\end{lstlisting}


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
