<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Erich Round" />

<meta name="date" content="2022-10-10" />

<title>Practical phylogenetic methods for linguistic typology</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<link rel="stylesheet" href="styles.css" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VSGK4KYDQZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VSGK4KYDQZ');
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">



<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  
  <!-- Added by SKC - LADAL image and thicker top with   -->
  <div class="container-fluid navbar-top" >
    <a href="index.html"> <!-- Make entire top row and text clickable home link  -->
        <div class="row">
            <div class="navbar-brand col-md-12">
              <img src="/content/ladal_icon_cas_tran_white_trimed.png" class="navbar-icon" alt="LADAL"/>
              <span class="navbar-title-note navbar-collapse collapse" >Language Technology and Data Analysis Laboratory</span>
            </div>
        </div>
    </a>
  </div>
  
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <!-- SKC removed  navbar brand -->
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">HOME</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    ABOUT LADAL
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="people.html">People | Collabs</a>
    </li>
    <li>
      <a href="news.html">News</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    EVENTS
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="workshops.html">Workshops</a>
    </li>
    <li>
      <a href="compthinking.html">Computational Thinking in HASS</a>
    </li>
    <li>
      <a href="webinars2022.html">LADAL Webinar Series 2022</a>
    </li>
    <li>
      <a href="opening.html">LADAL Webinar Series 2021</a>
    </li>
    <li>
      <a href="atapevents.html">ATAP Events</a>
    </li>
  </ul>
</li>
<li>
  <a href="tutorials.html">TUTORIALS</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    RESOURCES
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="links.html">Links</a>
    </li>
    <li>
      <a href="base.html">Tutorial stylesheet</a>
    </li>
  </ul>
</li>
<li>
  <a href="contact.html">CONTACT</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Practical phylogenetic methods for linguistic typology</h1>
<h4 class="author">Erich Round</h4>
<h4 class="date">2022-10-10</h4>

</div>


<p><img src="https://slcladal.github.io/images/uq1.jpg" width="100%" /></p>
<div id="introduction" class="section level1 unnumbered" number="">
<h1 class="unnumbered" number="">Introduction</h1>
<p>A perennial task in typology is the characterization of frequencies of traits of interest among the world’s languages. The scientific interest of such questions typically lies not merely in the contingent facts of today’s particular languages and language families, rather the goal is to characterize the nature of human language in general, using today’s contingent empirical data as evidence. One of the key challenges that makes this task difficult to carry out in a principled way is that languages are historically related to each other. This document is a practical introduction to the use of <em>phylogenetic comparative methods</em>, which will help to meet this challenge in a principled way.</p>
<p><strong>Preparation and session set up</strong></p>
<p>This tutorial is based on R. If you have not installed R or are new to it, you will find an introduction to and more information how to use R <a href="https://slcladal.github.io/intror.html">here</a>. For this tutorials, we need to install certain <em>packages</em> from an R <em>library</em> so that the scripts shown below are executed without errors. Before turning to the code in subsequent sections, please first install the packages by running the code below this paragraph. If you have already installed the packages mentioned below, then you can skip ahead and ignore this section. To install the necessary packages, simply run the following code - it may take some time (between 1 and 5 minutes to install all of the libraries so you do not need to worry if it takes some time).</p>
<pre class="r"><code># set options
options(stringsAsFactors = F)         # no automatic data transformation
options(&quot;scipen&quot; = 100, &quot;digits&quot; = 4) # suppress math annotation
# install packages
install.packages(&quot;tidyverse&quot;)
install.packages(&quot;flextable&quot;)
install.packages(&quot;devtools&quot;)
install.packages(&quot;phangorn&quot;)
# install klippy for copy-to-clipboard button in code chunks
devtools::install_github(&quot;rlesur/klippy&quot;)
devtools::install_github(&quot;erichround/phyloWeights&quot;, 
                         dependencies = T, 
                         INSTALL_opts = c(&quot;--no-multiarch&quot;))
devtools::install_github(&quot;erichround/glottoTrees&quot;, 
                         dependencies = T, 
                         INSTALL_opts = c(&quot;--no-multiarch&quot;))</code></pre>
<p>Next, we activate the packages.</p>
<pre class="r"><code># activate packages
library(tidyverse)
library(flextable)
library(phyloWeights)
library(glottoTrees)
library(ape)
# activate klippy for copy-to-clipboard button
klippy::klippy()</code></pre>
<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('left', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<p>Once you have installed R, RStudio, and have also initiated the session by executing the code shown above, you are good to go.</p>
<div id="an-intuitive-introduction-to-the-challenge-of-genealogy" class="section level2 unnumbered" number="">
<h2 class="unnumbered" number="">An intuitive introduction to the challenge of genealogy</h2>
<p>To get an intuitive notion of the challenge that is presented by the genealogical relatedness of languages, consider the small language family pictured in the figure below. It contains four languages, which are either SOV or SVO. The question is: What proportion of this family is SOV? Should you just count the languages, in which case the answer is literally 75%? This answer may seem not quite right, because now one half of the family is counting three times as much as the other half, just because it had the fortune of containing more languages. Put another way, the figure of 75% is strongly influenced by contingencies of history.</p>
<p><img src="phylo_files/figure-html/SOV-tree-1.png" width="672" /></p>
<p>In a LADAL seminar on 4 November, 2021 <span class="citation">(Macklin-Cordes and Round <a href="#ref-macklin-cordes_phylogenetic_2021" role="doc-biblioref">2021</a><a href="#ref-macklin-cordes_phylogenetic_2021" role="doc-biblioref">b</a>)</span> and in a related journal article <span class="citation">(Macklin-Cordes and Round <a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">2021</a><a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">a</a>)</span>, Jayden Macklin-Cordes and I review some of history of thinking in linguists’ attempts to account for historical relatedness of exactly this kind when comparing across languages. We also explain how <em>phylogenetic comparative methods</em> present the most principled response to it developed so far. We recommend reviewing either of these sources, since they cover the scientific content which corresponds to the practical, technical content in this tutorial. Here, we will not review the scientific content at any length.</p>
<p>This document provides a guide to the practical use of phylogenetic comparative methods for linguistic typology, specifically, the calculation of genealogically-sensitive proportions and averages. These are methods which provide an answer to the question: “When characterising the frequencies of traits among the world’s languages, how can we take genealogy into account?” Here we cover two methods for calculating genealogically-sensitive proportions and averages: the ‘ACL’ method <span class="citation">(Altschul, Carroll, and Lipman <a href="#ref-altschul_weights_1989" role="doc-biblioref">1989</a>)</span> and the ‘BM’ method <span class="citation">(Stone and Sidow <a href="#ref-stone_constructing_2007" role="doc-biblioref">2007</a>)</span>.</p>
<p>Because a key part of this kind of analysis is the preparation of a phylogenetic tree, an important component of the tutorial will be about how such trees can be prepared.</p>
<p>The tutorial is divided into four main sections. Section <a href="#Trees-in-R">Trees in R</a> is an introduction to how trees are represented in R. Section <a href="#Genealogically-sensitive-averages-and-proportions">Genealogically-sensitive averages and proportions</a> discusses the calculation of genealogically-sensitive proportions and averages. Section <a href="#Using-and-adapting-trees-from-glottolog.com">Using and adapting trees from glottolog.com</a> explains how typologists can prepare phylogenetic trees by adapting resources freely available from glottolog.com <span class="citation">(Hammarström et al. <a href="#ref-glottolog" role="doc-biblioref">2021</a>)</span>. And Section <a href="#Putting-it-together:-A-worked-example">Putting it together: A worked example</a> provides a worked example used in a typological investigation of sonority sequencing by <span class="citation">Yin (<a href="#ref-yin_violations_2020" role="doc-biblioref">2020</a>)</span>.</p>
<p>Much of the discussion below is an introduction to the functionality of two R packages, <code>glottoTrees</code> <span class="citation">(E. R. Round <a href="#ref-glottoTrees" role="doc-biblioref">2021</a><a href="#ref-glottoTrees" role="doc-biblioref">a</a>)</span> and <code>phyloWeights</code> <span class="citation">(E. R. Round <a href="#ref-phyloWeights" role="doc-biblioref">2021</a><a href="#ref-phyloWeights" role="doc-biblioref">b</a>)</span>, which have been specifically written for these tasks. The text of this tutorial is taken largely from the Supplementary Materials section S1 of <span class="citation">Macklin-Cordes and Round (<a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">2021</a><a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">a</a>)</span>.</p>
<!-- This document represents an empty R Markdown file (or Rmd file) for a LADAL tutorial. The R Markdown document for this tutorial can be downloaded [here](https://slcladal.github.io/content/base.Rmd). -->
<!-- You will also have to download the bibliography file from https://slcladal.github.io/content/bibliography.bib for the tutorial to be knitted correctly. Although the knitted (or rendered) html file will look different from the LADAL design (because we have modified the theme for the LADAL page), it will be just like a proper LADAL tutorial once we have knitted the Rmd file on our machines and integrated your tutorial into the LADAL website. -->
</div>
</div>
<div id="r-trees" class="section level1" number="1">
<h1 number="1"><span class="header-section-number">1</span> Trees in R</h1>
<p>This section discusses how trees are created, manipulated and plotted in R. Terminology we will use includes: <em>tips</em> at the ends of trees, which in a linguistic tree would usually be the languages or lects; the <em>branches</em> of a tree; the <em>interior nodes</em> or just <em>nodes</em> of a tree, where branches join together; and the <em>root</em> of the tree, its deepest node. R will represent trees as complex objects, in which the tips, nodes and branches all appear, along with labels for the tips and nodes.</p>
<p>One of the simplest methods of constructing a tree in R begins with a description of the tree using a form a bracketing notation known as the <em>Newick</em> standard <span class="citation">(Felsenstein, <a href="#ref-Newick" role="doc-biblioref">n.d.</a>)</span>. In its simplest form, a tree is represented in Newick format by a set of tip labels grouped by parentheses, separated by commas, and ending with a semicolon. For example, here is a string that represents a tree with four tips, <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code>, which we assign to the object <code>my_newick</code>:</p>
<pre class="r"><code>my_newick &lt;- &quot;(((A,B),C),D);&quot;</code></pre>
<p>A Newick-formatted string can then be converted to a tree object by supplying it as the <code>text</code> argument of the function <code>read.tree()</code>, from the <code>ape</code> package:</p>
<pre class="r"><code>my_tree &lt;- read.tree(text = my_newick)</code></pre>
<p>We can plot the tree using the <code>plot()</code> function:</p>
<pre class="r"><code>plot(my_tree)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>By default, trees in R are plotted horizontally following the convention in biology. The <code>glottoTrees</code> package provides a function <code>plot_glotto()</code> which plots trees in a more typical, downward-running linguistic format, as below.</p>
<pre class="r"><code>plot_glotto(my_tree)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-4-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The tree object <code>my_tree</code> which we defined above did not include information about branch lengths. In Newick format, branch lengths are written with a preceding colon and appear directly after a language or the closing bracket for a subgroup:</p>
<pre class="r"><code>my_newick2 &lt;- &quot;(((A:4,B:4):1,C:5):3,D:8);&quot;</code></pre>
<p>Converting this to a tree object and plotting it:</p>
<pre class="r"><code>my_tree2 &lt;- read.tree(text = my_newick2)
plot_glotto(my_tree2)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-6-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Trees can have labels not only for their tips, but also for their internal nodes. In linguistics, an internal node of a tree may be interpreted taxonomically, as representing a subgroup and labeled accordingly, or genealogically, as a proto-language from which the subgroup descends and labeled accordingly. In Newick format, labels for internal nodes are placed directly after a closing parenthesis. For example, here we add labels that reflect a genealogical interpretation of the nodes:</p>
<pre class="r"><code>my_newick3 &lt;- &quot;(((A:4,B:4)proto-AB:1,C:5)proto-ABC:3,D:8)proto-ABCD;&quot;
my_tree3 &lt;- read.tree(text = my_newick3)
plot_glotto(my_tree3)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Technically speaking, trees are represented by R as objects with a customised class called <code>phylo</code>.</p>
<pre class="r"><code>class(my_tree3)</code></pre>
<pre><code>## [1] &quot;phylo&quot;</code></pre>
<p>A <code>phylo</code> object stores information about the tree <em>topology</em> (i.e., its branching structure), the branch lengths, and the labels of the tips and nodes. In R we often use the <code>$</code> operator to access one object that is contained inside another. For instance, the object <code>y</code> contained within the larger object <code>x</code> would be referred to as <code>x$y</code>. Here are some examples:</p>
<pre class="r"><code>my_tree3$edge.length</code></pre>
<pre><code>## [1] 3 1 4 4 5 8</code></pre>
<pre class="r"><code>my_tree3$tip.label</code></pre>
<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot;</code></pre>
<pre class="r"><code>my_tree3$node.label</code></pre>
<pre><code>## [1] &quot;proto-ABCD&quot; &quot;proto-ABC&quot;  &quot;proto-AB&quot;</code></pre>
<p>Another object class in R, related to the <code>phylo</code> class, is the <code>multiPhylo</code> class. Objects of the <code>multiPhylo</code> class are used to store multiple <code>phylo</code> trees in a single, larger object.</p>
<pre class="r"><code>newick_a &lt;- &quot;(((A:4,B:4):1,C:5):3,D:8);&quot;
newick_b &lt;- &quot;((A:2,B:2):1,(C:1,D:1,E:1):2);&quot;
tree_a &lt;- read.tree(text = newick_a)
tree_b &lt;- read.tree(text = newick_b)
my_multiPhylo &lt;- c(tree_a, tree_b)
class(my_multiPhylo)</code></pre>
<pre><code>## [1] &quot;multiPhylo&quot;</code></pre>
<p>For reasons we won’t go into here, the <code>phylo</code> trees inside a <code>multiPhylo</code> object are not accessed using the <code>$</code> operator but using double square brackets. For example, here we refer to the second tree inside the object <code>my_multiPhylo</code> by writing <code>my_multiPhylo[[2]]</code>:</p>
<pre class="r"><code>plot_glotto(my_multiPhylo[[2]])</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-11-1.png" width="85%" style="display: block; margin: auto;" /></p>
<p>Before concluding this section, a final word is in order about the irrelevance of the left-to-right arrangement of trees. In a tree, there is no meaningful difference between (A,B) and (B,A): in both, A and B are sisters under a shared parent node. Similarly, these are all equivalent: (A,B,C), (A,C,B), (B,A,C), (B,C,A), (C,A,B) and (C,B,A). And likewise, these are all equivalent: (A,(B,C)), (A,(C,B)), ((B,C),A) and ((C,B),A).</p>
</div>
<div id="averages" class="section level1" number="2">
<h1 number="2"><span class="header-section-number">2</span> Genealogically-sensitive averages and proportions</h1>
<p>We now turn to the calculation of genealogically-sensitive proportions and averages. To begin, consider these six trees, which represent six different hypotheses about the genealogical relationships between languages <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code>. Also plotted here are the languages’ dominant word orders and their numbers of consonant phonemes.</p>
<p><img src="phylo_files/figure-html/unnamed-chunk-12-1.png" width="672" height="20%" /></p>
<p>Questions that we seek to answer are: what is the proportion of this set of languages that is SOV?; and what is the average number of consonant phonemes in this set of languages? Moreover, we want the answers to be sensitive to genealogy, and we’re interested in how the answers may vary according to which of these six genealogical hypotheses is adopted.</p>
<p>Calculating genealogically-sensitive averages and proportions will require two key components:</p>
<ol style="list-style-type: decimal">
<li>A <code>phylo</code> or <code>multiPhylo</code> object containing one or more trees.</li>
<li>A dataframe, which (i) contains the typological data to be averaged and (ii) relates that data to the tips of the trees.</li>
</ol>
<p>The <code>phylo</code> or <code>multiPhylo</code> object can be manually defined, as described in Section <a href="#Trees-in-R">Trees in R</a>, can be read from a file,<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> or it can be constructed by using and adjusting materials freely available from glottolog.com, as described below in Section <a href="#Using-and-adapting-trees-from-glottolog.com">Using and adapting trees from glottolog.com</a>. In this example, our six trees can be manually defined using the code below, which places them inside a single <code>multiPhylo</code> object named <code>multi_phylo_ABCD</code>:</p>
<pre class="r"><code>multiPhylo_ABCD &lt;- 
  c(read.tree(text = &quot;(((A:0.2,B:0.2,C:0.2):1.8,D:2):0.3);&quot;),
    read.tree(text = &quot;(((A:1,B:1,C:1):1,D:2):0.3);&quot;), 
    read.tree(text = &quot;(((A:1.8,B:1.8,C:1.8):0.2,D:2):0.3);&quot;), 
    read.tree(text = &quot;((((A:1,B:1):0.8,C:1.8):0.2,D:2):0.3);&quot;),
    read.tree(text = &quot;(((A:1.8,(B:1,C:1):0.8):0.2,D:2):0.3);&quot;),
    read.tree(text = &quot;(((A:1,B:1):1,(C:1.8,D:1.8):0.2):0.3);&quot;)
    )</code></pre>
<p>The dataframe can be manually defined or be read from a file. Perhaps the easiest method is to read from a file that you have created and saved in “CSV” (comma separated value) format. CSV files can be created in commercial spreadsheet software like Excel, and then read by R using the <code>read.csv()</code> function like this:</p>
<pre class="r"><code>my_dataframe &lt;- read.csv(&quot;my_csv_file.csv&quot;)</code></pre>
<p>The dataframe must contain one column named <code>tip</code> (note that in R, names of columns and other objects are case sensitive) plus at least one column containing numerical data. The contents of the <code>tip</code> column must be the same as the tip labels of the tree(s) in the <code>phylo</code> or <code>multiPhylo</code> object. The contents of the numerical columns will depend on whether a proportion or an average is desired. To calculate a proportion, fill a numerical column with 1 if the language possesses the property and 0 if it does not. To calculate an average, fill a numerical column with the values of the variable for each language.</p>
<p>For this example, the dataframe required is defined in the code below. In addition to the <code>tip</code> column, it contains two numerical columns, <code>is_SOV</code> and <code>n_consonants</code>. As good housekeeping, we recommend using column names of the form <code>is_X</code> or <code>has_X</code> for columns that contain data for proportions, and names of the form <code>n_X</code> for columns that contain counts to be averaged.</p>
<pre class="r"><code>data_ABCD &lt;- data.frame(tip = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), 
                        is_SOV = c(1, 1, 1, 0), 
                        n_consonants = c(18, 20, 22, 40),
                        stringsAsFactors = FALSE)</code></pre>
<p>Genealogically-sensitive averages and proportions are obtained using the <code>phyloWeights</code> function <code>phylo_average()</code>, specifying its arguments <code>phy</code> and <code>data</code> as in the example below. Here we have assigned the output of this function to a new object <code>results_ABCD</code>. We recommend always assigning the output of <code>phylo_average()</code> to an object. We will see below how to extract from it the various parts of the results.</p>
<pre class="r"><code>results_ABCD &lt;- phylo_average(phy = multiPhylo_ABCD, data = data_ABCD)</code></pre>
<p>The function <code>phylo_average()</code> may take up to several minutes to run if the tree is large, or many trees are provided. It will return error messages if the inputs provided to it are not what is required.</p>
<p>The results object will contain several parts, which can be accessed using the <code>$</code> operator. In <code>$phy</code> will be the tree(s) that were supplied and in <code>$data</code> will be the dataframe that was supplied, e.g.:</p>
<pre class="r"><code>results_ABCD$data</code></pre>
<pre><code>##   tip is_SOV n_consonants
## 1   A      1           18
## 2   B      1           20
## 3   C      1           22
## 4   D      0           40</code></pre>
<p>In <code>$ACL_averages</code> is a dataframe containing the genealogically-sensitive averages/proportions according to the ACL method. The dataframe has one row per tree and one column for each of the numerical columns in the <code>data</code> dataframe. Here you can see how the answer to our questions changes as the hypotheses about the tree changes.</p>
<pre class="r"><code>results_ABCD$ACL_averages</code></pre>
<pre><code>##    tree    is_SOV n_consonants
## 1 tree1 0.5172414     29.65517
## 2 tree2 0.6000000     28.00000
## 3 tree3 0.7142857     25.71429
## 4 tree4 0.6768559     26.63755
## 5 tree5 0.6768559     26.28821
## 6 tree6 0.7115385     25.92308</code></pre>
<p>In <code>$BM_averages</code> appear the genealogically-sensitive averages or proportions obtained using the BM method:</p>
<pre class="r"><code>results_ABCD$BM_averages</code></pre>
<pre><code>##    tree    is_SOV n_consonants
## 1 tree1 0.5568599     28.86280
## 2 tree2 0.6952381     26.09524
## 3 tree3 0.7468354     25.06329
## 4 tree4 0.7256904     25.56443
## 5 tree5 0.7256904     25.40796
## 6 tree6 0.7288732     25.50704</code></pre>
<p>In terms of their inner workings, both methods work by assigning weights to languages, and those weights then reflect how much each language contributes to the final result. These weights can be found in <code>$ACL_weights</code> and <code>$BM_weights</code>. You might like to compare, for each tree, the weights for languages <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> with the positions of the languages in the tree, in order to get an idea of how the weights relate to the tree shape.</p>
<pre class="r"><code>results_ABCD$ACL_weights</code></pre>
<pre><code>##   tip     tree1 tree2     tree3     tree4     tree5     tree6
## 1   A 0.1724138   0.2 0.2380952 0.1965066 0.2838428 0.2115385
## 2   B 0.1724138   0.2 0.2380952 0.1965066 0.1965066 0.2115385
## 3   C 0.1724138   0.2 0.2380952 0.2838428 0.1965066 0.2884615
## 4   D 0.4827586   0.4 0.2857143 0.3231441 0.3231441 0.2884615</code></pre>
<pre class="r"><code>results_ABCD$BM_weights</code></pre>
<pre><code>##   tip     tree1     tree2     tree3     tree4     tree5     tree6
## 1   A 0.1856200 0.2317460 0.2489451 0.2288579 0.2679747 0.2288732
## 2   B 0.1856200 0.2317460 0.2489451 0.2288579 0.2288579 0.2288732
## 3   C 0.1856200 0.2317460 0.2489451 0.2679747 0.2288579 0.2711268
## 4   D 0.4431401 0.3047619 0.2531646 0.2743096 0.2743096 0.2711268</code></pre>
<p>It is possible to save any of these dataframes to a file using the <code>write.csv()</code> function, for example:</p>
<pre class="r"><code>write.csv(results_ABCD$ACL_averages, file = &quot;my_ACL_averages.csv&quot;)</code></pre>
</div>
<div id="glottolog" class="section level1" number="3">
<h1 number="3"><span class="header-section-number">3</span> Using and adapting trees from glottolog.com</h1>
<p>As we have seen, using phylogenetic comparative methods, such as methods for calculating genealogically-sensitive averages, requires us to have one or more trees, expressing hypotheses about genealogical relationships among the languages. In this section we address the questions, where can linguists obtain their trees from?; and how can linguists adapt those trees to reflect their own hypotheses about language relatedness?</p>
<p>Our starting point is glottolog.com <span class="citation">(Hammarström et al. <a href="#ref-glottolog" role="doc-biblioref">2021</a>)</span>, a major online publication which contains many useful resources for quantitative typology. The R package <code>glottoTrees</code> <span class="citation">(E. R. Round <a href="#ref-glottoTrees" role="doc-biblioref">2021</a><a href="#ref-glottoTrees" role="doc-biblioref">a</a>)</span> has been written to help linguists make the most of these resources, including by modifying them as they desire. This section covers the glottolog data itself and the functionality of <code>glottoTrees</code>. We introduce glottolog’s genealogical data in Section <a href="#Glottolog&#39;s-genealogical-data">Glottolog’s genealogical data</a>, discussing how to locate metadata about languages and families of interest, and how to view glottolog’s linguistic family trees. Since genealogically-sensitive averages and proportions require all of the languages in the study to be linked in a tree, we then discuss how glottolog’s individual trees can be combined into larger, composite trees in Section @ref(combining-trees). Since typological studies will often examine language varieties at a level of granularity that differs from glottolog’s own, in Section <a href="#How-to-modify-trees">How to modify trees</a> we discuss how to add and remove languages from trees. In Section <a href="#How-to-add-branch-lengths">How to add branch lengths</a> we discuss how to add branch lengths to trees, since branch lengths are necessary for the calculation of genealogically-sensitive averages and proportions. Section @ref(exporting) discusses how to export trees for use with other software.</p>
<div id="glottolog-genealogical" class="section level2" number="3.1">
<h2 number="3.1"><span class="header-section-number">3.1</span> Glottolog’s genealogical data</h2>
<p>Glottolog provides metadata about the world’s language varieties, their division into language families and the hierarchical subgrouping of languages inside those families. Naturally, there are many points of contention in linguistics about what the world’s stock of languages and dialects actually is, how it groups into families, and how the families themselves are subgrouped. Glottolog provides one set of answers, and structures them in a way which provides typologists with a basis for carrying out changes to suit their own hypotheses. In later sections we will see how this can be done. In this section we describe glottolog’s own global linguistic metadata.</p>
<p>At time of writing, the current version of glottolog is v4.4. The <code>glottoTrees</code> package contains a copy of the v4.4 metadata covering language names, language identification codes, family names, geographical groupings, and family trees. The original metadata files that contain this information are currently available at <a href="https://glottolog.org/meta/downloads" class="uri">https://glottolog.org/meta/downloads</a>, where a file named <code>tree_glottolog_newick.txt</code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> contains glottolog’s trees, and <code>languages_and_dialects_geo.csv</code> provides geographical metadata.</p>
<p>Language metadata can be accessed using the <code>glottoTrees</code> function <code>get_glottolog_languages()</code>. This function returns a dataframe of close to twenty-six thousand rows. To view it in full, we suggest saving it to a CSV file and opening it in spreadsheet software such as Excel:</p>
<pre class="r"><code>language_metadata &lt;- get_glottolog_languages()
write.csv(language_metadata, &quot;language_metadata.csv&quot;)</code></pre>
<p>Here are the first ten rows:</p>
<pre class="r"><code>language_metadata &lt;- get_glottolog_languages()
head(language_metadata, n = 10)</code></pre>
<pre><code>##    glottocode isocodes       name name_in_tree position tree
## 1    3adt1234          3Ad-Tekles   3Ad-Tekles      tip  391
## 2    aala1237              Aalawa       Aalawa      tip   94
## 3    aant1238          Aantantara   Aantantara      tip   90
## 4    aari1238     &lt;NA&gt;       &lt;NA&gt;   Aari-Gayil     node   22
## 5    aari1239      aiw       Aari         Aari      tip   22
## 6    aari1240      aay     Aariya       Aariya     &lt;NA&gt;   NA
## 7    aasa1238      aas      Aasax        Aasax      tip  391
## 8    aasd1234            Aasdring     Aasdring      tip  269
## 9    aata1238           Aatasaara    Aatasaara      tip   90
## 10   abaa1238              Rngaba       Rngaba      tip  345
##                tree_name
## 1           Afro-Asiatic
## 2           Austronesian
## 3  NuclearTransNewGuinea
## 4            SouthOmotic
## 5            SouthOmotic
## 6                   &lt;NA&gt;
## 7           Afro-Asiatic
## 8          Indo-European
## 9  NuclearTransNewGuinea
## 10          Sino-Tibetan</code></pre>
<p>Listed here are glottolog’s languages, dialects, subgroups and families. These entities are identified by a name, an ISO-639-3 code if available (format: three letters) and a glottolog-specific <em>glottocode</em> (format: four letters followed by four digits<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>). Also described is the entity’s relationship to a glottolog tree: the representation of its name in the tree (which may differ slightly from the name used elsewhere by glottolog<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>), its position (as tip or node), and the tree’s number and name.</p>
<p>By default, the metadata functions in <code>glottoTrees</code>, such as <code>get_glottolog_languages()</code>, will return information about the most recent version of glottolog which the package contains. To access older versions, supply the version number via the <code>glottolog_version</code> argument:<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<pre class="r"><code>language_metadata_v4.3 &lt;- get_glottolog_languages(glottolog_version = &quot;4.3&quot;)
head(language_metadata_v4.3, n = 10)</code></pre>
<pre><code>##    glottocode isocodes       name name_in_tree position tree
## 1    3adt1234          3Ad-Tekles   3Ad-Tekles      tip  186
## 2    aala1237              Aalawa       Aalawa      tip  205
## 3    aant1238          Aantantara   Aantantara      tip  145
## 4    aari1238     &lt;NA&gt;       &lt;NA&gt;   Aari-Gayil     node   85
## 5    aari1239      aiw       Aari         Aari      tip   85
## 6    aari1240      aay     Aariya       Aariya     &lt;NA&gt;   NA
## 7    aasa1238      aas      Aasax        Aasax      tip  186
## 8    aasd1234            Aasdring     Aasdring      tip  179
## 9    aata1238           Aatasaara    Aatasaara      tip  145
## 10   abaa1238              Rngaba       Rngaba      tip  329
##                tree_name
## 1           Afro-Asiatic
## 2           Austronesian
## 3  NuclearTransNewGuinea
## 4            SouthOmotic
## 5            SouthOmotic
## 6                   &lt;NA&gt;
## 7           Afro-Asiatic
## 8          Indo-European
## 9  NuclearTransNewGuinea
## 10          Sino-Tibetan</code></pre>
<p>Briefer metadata about glottolog’s language families can be accessed using the <code>glottoTrees</code> function <code>get_glottolog_families()</code>. This returns a dataframe of 420 rows, so to view it in full, we also suggest saving it to a CSV file and opening it in spreadsheet software. Here are the first ten rows:</p>
<pre class="r"><code>family_metadata &lt;- get_glottolog_families()
head(family_metadata, n = 10)</code></pre>
<pre><code>##    tree           tree_name n_tips n_nodes main_macroarea
## 1     1                 Yam     33      18      Papunesia
## 2     2     Mongolic-Khitan     66      25        Eurasia
## 3     3 Kol{PapuaNewGuinea}      2       1      Papunesia
## 4     4       Namla-Tofanma      2       1      Papunesia
## 5     5          Tanahmerah      1       1      Papunesia
## 6     6         Jarawa-Onge      2       1        Eurasia
## 7     7        Ta-Ne-Omotic     29      15         Africa
## 8     8              Pomoan     10       7  North America
## 9     9         WesternDaly     14       7      Australia
## 10   10           Yangmanic      3       1      Australia</code></pre>
<p>Glottolog v4.4 divides the world’s languages into 420 families, including 138 isolates, and it provides a tree for each. Together, the 420 trees contain 8,209 internal nodes and 17,008 tips, many of which represent varieties that would typically be considered dialects. Geographically, glottolog assigns each language variety to one of six <em>macroareas</em>: Africa, Australia, Eurasia, Papunesia, South America or North America. The <code>glottoTrees</code> metadata includes a column <code>main_macroarea</code>. This is the one macroarea which contains more of the family’s language varieties than any other. We will see how this information can be useful in Section @ref(combining-trees).</p>
<p>Glottolog’s 420 family trees are stored in a <code>multiPhylo</code> object named <code>glottolog_trees_v4.4</code>. For example, here is glottolog’s representation of the Great Andamanese family, which is tree 340 within the object <code>glottolog_trees_v4.4</code>. For readability, we plot this tree horizontally:</p>
<pre class="r"><code>tree_GA &lt;- glottolog_trees_v4.4[[340]]
plot(tree_GA, x.lim = c(-0.3, 14))</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-23-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>Just above, we obtained the tree for Great Andamanese by referring to its tree number (340) in the <code>glottolog_trees_v4.4</code> object. The package <code>glottoTrees</code> also provides a function <code>get_glottolog_trees()</code> which enables trees to be obtained using the glottolog name for their families, for instance:</p>
<pre class="r"><code>tree_GA &lt;- get_glottolog_trees(&quot;GreatAndamanese&quot;)
plot(tree_GA, x.lim = c(-0.3, 14))</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-24-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>If you know the name of one or more families and would like to now the number of their trees, use <code>which_tree()</code>:</p>
<pre class="r"><code>which_tree(&quot;GreatAndamanese&quot;)</code></pre>
<pre><code>## GreatAndamanese 
##             340</code></pre>
<pre class="r"><code>which_tree(c(&quot;Turkic&quot;, &quot;Tupian&quot;, &quot;Tuu&quot;))</code></pre>
<pre><code>## Turkic Tupian    Tuu 
##    217     32     76</code></pre>
<p>Both <code>get_glottolog_trees()</code> and <code>which_tree()</code> allow the usage of a <code>glottolog_version</code> argument, to refer to older versions of glottolog. For instance, here are the tree numbers of the same families in version 4.1:</p>
<pre class="r"><code>which_tree(&quot;GreatAndamanese&quot;, glottolog_version = &quot;4.1&quot;)</code></pre>
<pre><code>## GreatAndamanese 
##               6</code></pre>
<pre class="r"><code>which_tree(c(&quot;Turkic&quot;, &quot;Tupian&quot;, &quot;Tuu&quot;), glottolog_version = &quot;4.1&quot;)</code></pre>
<pre><code>## Turkic Tupian    Tuu 
##     66    297     80</code></pre>
<p>In glottolog’s trees, the tip labels are rather long, consisting of a name followed by a glottocode in angled brackets, an ISO code in angled brackets (if one exists) and possibly the string “-l-”. Node labels (not shown in the tree above) have the same structure. The <code>glottoTrees</code> function <code>abridge_labels()</code> will shorten labels to just the glottocode, for example:</p>
<pre class="r"><code>tree_GA_abr &lt;- abridge_labels(tree_GA)
plot_glotto(tree_GA_abr)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-27-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The function <code>abridge_labels()</code> will issue a warning if there are tip or node labels in which it is unable to identify a glottocode. We will see an example of this shortly below.</p>
<p>In glottolog’s trees, the branches are all of equal length. We will discuss how to assign more realistic branch lengths in Section <a href="#How-to-add-branch-lengths">How to add branch lengths</a>.</p>
</div>
<div id="combining-trees" class="section level2" number="3.2">
<h2 number="3.2"><span class="header-section-number">3.2</span> How to combine trees</h2>
<p>As discussed <span class="citation">Macklin-Cordes and Round (<a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">2021</a><a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">a</a>)</span>, the comparison of languages across language families unavoidably carries a commitment to a genealogical hypothesis, even if that hypotheses is, tacitly, that all families are equally (un)related. Given that making such hypotheses is unavoidable, it will be most beneficial for progress in the field to make them explicit. To enable typologists to explore genealogical hypotheses and to make those hypotheses explicit, <code>glottoTrees</code> provides tools for combining multiple glottolog trees into one.</p>
<p>To begin with a small example, here we combine five glottolog families to represent the hypothesised Arnhem group in northern Australia <span class="citation">(Green <a href="#ref-green_proto_2003" role="doc-biblioref">2003</a>)</span>. First we create a <code>multiPhylo</code> object containing the five glottolog language families (Gunwinyguan, Mangarrayi-Maran, Maningrida, and the isolates Kungarakany and Gaagudju):</p>
<pre class="r"><code>arnhem_family_names &lt;- 
  c(&quot;Gunwinyguan&quot;, &quot;Mangarrayi-Maran&quot;, &quot;Maningrida&quot;, &quot;Kungarakany&quot;, &quot;Gaagudju&quot;)
multiPhylo_arnhem &lt;- get_glottolog_trees(arnhem_family_names)</code></pre>
<p>The <code>glottoTrees</code> function <code>assemble_rake()</code> enables the trees in a <code>multiPhylo</code> object to be assembled into a single tree with a rake structure at its root. Here we apply <code>assemble_rake()</code> to our <code>multiPhylo</code> object and assign the resulting, single tree to the object <code>tree_arnhem</code>.</p>
<pre class="r"><code>tree_arnhem &lt;- assemble_rake(multiPhylo_arnhem)</code></pre>
<p>For plotting, it will be convenient to shorten the labels in the tree to just the glottocodes, using <code>abridge_labels()</code>. However, the root node in our newly created tree <code>tree_arnhem</code> has no label. Accordingly, the function <code>abridge_labels()</code> will issue a warning, that it encountered one node without a glottocode. This is not an error message, and <code>abridge_labels()</code> still shortens all labels to glottocodes where it can; it is just flagging the fact that it was not able to do so in all cases.</p>
<pre class="r"><code>tree_arnhem_abr &lt;- abridge_labels(tree_arnhem)</code></pre>
<pre><code>## Warning in abridge_labels(tree_arnhem): Labels without glottocodes were detected
## and left unchanged for: 0 tip(s); 1 node(s):</code></pre>
<p>Plotting the resulting tree enables us to inspect our newly created Arnhem tree. Note how all five families are joined to the root in a rake-like structure, without any additional subgrouping.</p>
<pre class="r"><code>plot_glotto(tree_arnhem_abr, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-29-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>It is possible to give a combined tree more structure, by using <code>assemble_rake()</code> iteratively. For instance, suppose we wished to hypothesise that Gunwinyguan, Mangarrayi-Maran and Maningrida form their own subgroup. First, we create a <code>multiPhylo</code> object containing those three trees, and combine it into a single rake tree, which we call <code>tree_A</code>:</p>
<pre class="r"><code>multiPhylo_A &lt;- get_glottolog_trees(c(&quot;Gunwinyguan&quot;, &quot;Mangarrayi-Maran&quot;, &quot;Maningrida&quot;))
tree_A &lt;- assemble_rake(multiPhylo_A)</code></pre>
<p>Then we create the final tree by combining <code>tree_A</code> with the two isolate family trees:</p>
<pre class="r"><code>multiPhylo_arnhem2 &lt;- c(tree_A, get_glottolog_trees(c(&quot;Kungarakany&quot;, &quot;Gaagudju&quot;)))
tree_arnhem2 &lt;- assemble_rake(multiPhylo_arnhem2)
tree_arnhem2_abr &lt;- abridge_labels(tree_arnhem2)</code></pre>
<pre><code>## Warning in abridge_labels(tree_arnhem2): Labels without glottocodes were
## detected and left unchanged for: 0 tip(s); 2 node(s): ,</code></pre>
<pre class="r"><code>plot_glotto(tree_arnhem2_abr, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-31-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Typological studies often examine languages from very many families. To group all 420 families into a single ‘supertree’, <code>glottoTrees</code> provides the function <code>assemble_supertree()</code>. By default, the function returns a supertree that divides first into glottolog’s six macroareas, with an internal node for each, and directly below these macroarea nodes appear all of the glottolog families, grouped by their <code>main_macroarea</code> mentioned in Section <a href="#Glottolog&#39;s-genealogical-data">Glottolog’s genealogical data</a> above. This tree is enormous, so we do not plot it here. It is obtained like this:</p>
<pre class="r"><code>my_supertree &lt;- assemble_supertree()</code></pre>
<p>The highest-level, macroarea groupings can also be controlled through the function’s argument <code>macro_groups</code>. For instance, to group all of the world’s families directly into a 420-pronged rake structure, set <code>macro_groups = NULL</code>:</p>
<pre class="r"><code>my_supertree &lt;- assemble_supertree(macro_groups = NULL)</code></pre>
<p>It is also possible to group macroareas together, for example, to combine North and South America into a single group. Grouping of macroareas is achieved by setting the <code>macro_groups</code> argument to a <em>list</em> whose items are the desired groups of macroareas. Each group will then appear as one of the highest-level nodes of the tree, and all of its families below it. For instance, to keep all of glottolog’s macroareas separate, but to combine North and South America into a single group, the following code would be used. First we define a list, which we’ve called <code>my_list</code>, within which any groupings containing more than one macroarea are represented as a vector, using the <code>c()</code> function:</p>
<pre class="r"><code>my_list &lt;- list(&quot;Africa&quot;, &quot;Australia&quot;, &quot;Eurasia&quot;, &quot;Papunesia&quot;,
                c(&quot;South America&quot;, &quot;North America&quot;))</code></pre>
<p>We then use that list as the <code>macro_groups</code> argument of <code>assemble_supertree()</code>:</p>
<pre class="r"><code>my_supertree &lt;- assemble_supertree(macro_groups = my_list)</code></pre>
<p>Taking a second example, to create a supertree containing only the families whose <code>main_macroarea</code> is either Africa or Eurasia, and to place Africa and Eurasia under separate, highest-level nodes, we would use:</p>
<pre class="r"><code>my_list &lt;- list(&quot;Africa&quot;, &quot;Eurasia&quot;)
my_supertree &lt;- assemble_supertree(macro_groups = my_list)</code></pre>
</div>
<div id="filter-tips" class="section level2" number="3.3">
<h2 number="3.3"><span class="header-section-number">3.3</span> How to modify trees</h2>
<p>There are several reasons why typologists may wish to use a tree that departs from the glottolog trees. Most commonly, a typological study will cover a set of languages that differs from the set of tips in any single glottolog tree, either through the exclusion of some of the lects that glottolog represents as tips or through the distinction of additional lects. A third case that can arise is when glottolog places one or more dialects at the tree’s tips and more a general, language node above them. The typologist may have data that applies to the language (an internal node) rather than the dialects (the tips), yet the calculation of genealogically-sensitive averages and proportions requires one’s typological variables to be related to the tips of trees, not to internal nodes. In these cases and many others, the typologist may wish to alter the glottolog tree to suit the purposes of the research. The <code>glottoTrees</code> package supplies a set of functions to aid in performing each of these tree manipulations. In this section we introduce them and illustrate their use.</p>
<p>In the following examples, we will make use glottolog’s representation of the Great Andamanese family, whose labels we shorten to just the glottocodes using <code>abridge_labels()</code>:</p>
<pre class="r"><code>tree_GA &lt;- get_glottolog_trees(&quot;GreatAndamanese&quot;)
tree_GA_abr &lt;- abridge_labels(tree_GA)
plot_glotto(tree_GA_abr)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-37-1.png" width="70%" style="display: block; margin: auto;" /></p>
<div id="how-to-remove-tips" class="section level3" number="3.3.1">
<h3 number="3.3.1"><span class="header-section-number">3.3.1</span> How to remove tips</h3>
<p>Firstly, we illustrate the removal of tips from a tree. There are two functions in <code>glottoTrees</code> for doing this. The function <code>remove_tip()</code> works by specifying which tips are to be removed, while the function <code>keep_tip()</code> works by specifying which tips are to be retained. First we will remove three of the original ten tips in the Great Andamanese tree. We do this by setting the <code>label</code> argument of <code>remove_tip()</code> to a vector containing the labels of the tips to be removed. Within the vector, the labels can appear in any order.</p>
<pre class="r"><code>tree_GAa &lt;- remove_tip(tree_GA_abr, label = c(&quot;akab1249&quot;, &quot;akak1251&quot;, &quot;apuc1241&quot;))
plot_glotto(tree_GAa)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-38-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>In this next example, we remove the tips <code>akab1249</code> and <code>akar1243</code>. These tips are the only tips that sit below the internal node <code>sout2683</code>. This is significant, because it triggers a convention in tree manipulation, that if all tips below a node are removed, then the node is removed also. We see that here:</p>
<pre class="r"><code>tree_GAb &lt;- remove_tip(tree_GA_abr, label = c(&quot;akab1249&quot;, &quot;akar1243&quot;))
plot_glotto(tree_GAb)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-39-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We now illustrate the usage of the <code>glottoTrees</code> function <code>keep_tip()</code>. Here we use it to retain six of the original ten tips in the Great Andamanese. We do this by setting the <code>label</code> argument to a vector containing the labels of the six desired tips.</p>
<pre class="r"><code>tree_GAc &lt;- keep_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1251&quot;, &quot;akac1240&quot;,
                                            &quot;akak1252&quot;, &quot;apuc1241&quot;, &quot;okoj1239&quot;))
plot_glotto(tree_GAc)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-40-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>As before, if our use of <code>keep_tip()</code> results in a node having all of the tips below it removed, then the node will also be removed automatically. This is illustrated here, where the node <code>boca1235</code> is removed automatically because neither of the tips below it are kept:</p>
<pre class="r"><code>tree_GAd &lt;- keep_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1251&quot;, &quot;akak1252&quot;,
                                            &quot;apuc1241&quot;, &quot;okoj1239&quot;))
plot_glotto(tree_GAd)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-41-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-remove-tips-and-convert-nodes-to-tips" class="section level3" number="3.3.2">
<h3 number="3.3.2"><span class="header-section-number">3.3.2</span> How to remove tips and convert nodes to tips</h3>
<p>As mentioned earlier, many of the tips in glottolog’s trees correspond to dialects, with languages represented as nodes above the dialectal tips. One usage case we foresee is that a typologist will wish to study a set of language varieties, some of which correspond to glottolog’s tips and some of which correspond to nodes. The <code>glottoTrees</code> function <code>keep_as_tips()</code> takes an argument <code>label</code> which can contain both tip labels and node labels. Any tips will be kept, and any nodes will be converted into tips, with all of the structure below them being removed. Be mindful when using <code>keep_as_tips()</code> that it is not possible to both convert a node into a tip and also retain the structure below it, such as tips that it dominates. Here we keep the same tips as in the tree above, while also converting the node <code>boca1235</code> into a tip:<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<pre class="r"><code>tree_GAe &lt;- keep_as_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1251&quot;, &quot;akak1252&quot;,
                                               &quot;apuc1241&quot;, &quot;okoj1239&quot;, &quot;boca1235&quot;))
plot_glotto(tree_GAe)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-42-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>One workflow that we envision for <code>keep_as_tip()</code> is that the typologist has prepared a CSV file, one of whose columns is named <code>tip</code> and contains the glottocodes of all the language varieties in the study. This CSV file can be loaded in R and assigned to a dataframe, and then its <code>tip</code> column can be passed to <code>keep_as_tip()</code> as the value of the <code>labels</code> argument, like this:</p>
<pre class="r"><code>my_dataframe &lt;- read.csv(&quot;my_data_file.csv&quot;, stringsAsFactors = FALSE)
my_new_tree &lt;- keep_as_tip(my_old_tree, label = my_dataframe$tip)</code></pre>
<p>To just convert one or more nodes into tips, use <code>convert_to_tip()</code>, as we do here to convert the nodes <code>okol1242</code> and <code>sout2683</code> to tips:</p>
<pre class="r"><code>tree_GAf &lt;- convert_to_tip(tree_GA_abr, label = c(&quot;okol1242&quot;, &quot;sout2683&quot;))
plot_glotto(tree_GAf)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-44-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-remove-internal-nodes" class="section level3" number="3.3.3">
<h3 number="3.3.3"><span class="header-section-number">3.3.3</span> How to remove internal nodes</h3>
<p>Sometimes, the removal of tips will cause one or more of the remaining tips to sit below a node which dominates only it. This reflects that fact that <code>remove_tip()</code>, <code>keep_tip()</code> and <code>keep_as_tip()</code> all preserve the original <em>depth</em> of any tips that remain in the tree (you may like to confirm this by reviewing the plots above). Depending on the researcher’s needs, this outcome may or may not be desirable. If it is undesirable, then non-branching, internal nodes can be removed using the <code>glottoTrees</code> function <code>collapse_node()</code>. For instance, here we remove two of the non-branching nodes from the tree <code>tree_GAc</code> above, by naming them in the <code>label</code> argument of <code>collapse_node()</code>. In the resulting tree, these nodes have been removed, thus reducing the depth of the tips below them:</p>
<pre class="r"><code>tree_GAg &lt;- collapse_node(tree_GAc, label = c(&quot;boca1235&quot;, &quot;okol1242&quot;))
plot_glotto(tree_GAg)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-45-1.png" width="55%" style="display: block; margin: auto;" /></p>
<p>When deciding whether to collapse nodes, in can be handy to know which nodes in a tree that have only one child below them. The function <code>nonbranching_nodes()</code> will return a vector of all such nodes, for example:</p>
<pre class="r"><code>nonbranching_nodes(tree_GAc)</code></pre>
<pre><code>## [1] &quot;okol1242&quot; &quot;boca1235&quot; &quot;jeru1239&quot; &quot;sout2683&quot;</code></pre>
<pre class="r"><code>nonbranching_nodes(tree_GAg)</code></pre>
<pre><code>## [1] &quot;jeru1239&quot; &quot;sout2683&quot;</code></pre>
<p>The function <code>collapse_node()</code> can also be used to alter a subgrouping hypothesis, and specifically, to remove a layer of subgrouping, converting a nested structure ((A,B),C) into a flat structure (A,B,C). For instance, here we remove the <code>okol1242</code> node of the original glottolog Great Andamanese tree, converting its two daughter languages into sisters of <code>okoj1239</code>:</p>
<pre class="r"><code>tree_GAh &lt;- collapse_node(tree_GA_abr, label= &quot;okol1242&quot;)
plot_glotto(tree_GAh)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-47-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-add-tips" class="section level3" number="3.3.4">
<h3 number="3.3.4"><span class="header-section-number">3.3.4</span> How to add tips</h3>
<p>The function <code>add_tip()</code> allows tips to be added to a tree. The <code>label</code> argument specifies the name of the new tip, while <code>parent_label</code> specifies the label of the node below which the new tip should appear. Here we add a tip <code>xxxx1234</code> below the node <code>sout2683</code>:</p>
<pre class="r"><code>tree_GAi &lt;- add_tip(tree_GA_abr, label = &quot;xxxx1234&quot;, parent_label = &quot;sout2683&quot;)
plot_glotto(tree_GAi)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-48-1.png" width="55%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-clone-tips" class="section level3" number="3.3.5">
<h3 number="3.3.5"><span class="header-section-number">3.3.5</span> How to clone tips</h3>
<p>Next we illustrate the cloning of tips. Cloning tips may be useful when glottolog provides only one glottocode, and thus only one tree tip, corresponding to multiple lects in the typologist’s study. To clone a tip, use the function <code>clone_tip()</code> and in the <code>label</code> argument, provide a vector of the tips to be cloned. Here we clone tips <code>akar1243</code> and <code>akak1252</code>:</p>
<pre class="r"><code>tree_GAj &lt;- clone_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1252&quot;))
plot_glotto(tree_GAj)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-49-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>By default, clones are added to the tree as sisters directly beneath the parent node of the original tip. An alternative is to create a new subgroup for each set of sister clones, using the <code>subgroup</code> argument and setting it to <code>subgroup = TRUE</code>. Each newly created subgroup node is given a label that matches the cloned tips it dominates:</p>
<pre class="r"><code>tree_GAk &lt;- clone_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1252&quot;), subgroup = TRUE)
plot_glotto(tree_GAk)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-50-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>It is also possible to make more than one clone using the <code>n</code> argument. Here we create three new clones of <code>akab1248</code> and place them in a subgroup:</p>
<pre class="r"><code>tree_GAl &lt;- clone_tip(tree_GA_abr, label = &quot;akab1248&quot;, n = 3, subgroup = TRUE)
plot_glotto(tree_GAl)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-51-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>One of the consequences of cloning tips is that the in the resulting tree, not all tips will have distinct names. The function <code>apply_duplicate_suffixes()</code> will add a suffix to any tips with duplicate labels, to make them unique.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> The suffix will consist of a hyphen followed by a number. Here we add suffixes to the tree <code>tree_GAj</code>:</p>
<pre class="r"><code>tree_GAm &lt;- apply_duplicate_suffixes(tree_GAj)
plot_glotto(tree_GAm)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-52-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-move-a-tip" class="section level3" number="3.3.6">
<h3 number="3.3.6"><span class="header-section-number">3.3.6</span> How to move a tip</h3>
<p>Using the function <code>move_tip()</code>, a tip can be moved to a new position, beneath a new parent node (one of the nodes already in the tree) which is specified with the <code>parent_label</code> argument:</p>
<pre class="r"><code>tree_GAn &lt;- move_tip(tree_GA_abr, label = &quot;apuc1241&quot;, parent_label = &quot;jeru1239&quot;)
plot_glotto(tree_GAn)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-53-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-move-a-node-and-its-descendants" class="section level3" number="3.3.7">
<h3 number="3.3.7"><span class="header-section-number">3.3.7</span> How to move a node and its descendants</h3>
<p>In a similar fashion, the function <code>move_node()</code> is used to move an internal node, along with all of the structure below it, to a position beneath a new parent node:</p>
<pre class="r"><code>tree_GAo &lt;- move_node(tree_GA_abr, label = &quot;jeru1239&quot;, parent_label = &quot;okol1242&quot;)
plot_glotto(tree_GAo)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-54-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="summary-a-general-purpose-toolkit-for-curating-trees-topology" class="section level3" number="3.3.8">
<h3 number="3.3.8"><span class="header-section-number">3.3.8</span> Summary: a general-purpose toolkit for curating trees’ topology</h3>
<p>The functions <code>remove_tip()</code>, <code>keep_tip()</code>, <code>keep_as_tip()</code>, <code>convert_to_tip()</code>, <code>collapse_node()</code>, <code>add_tip()</code>, <code>clone_tip()</code>, <code>move_tip()</code> and <code>move_node()</code> provide a general-purpose toolkit for modifying a single glottolog tree, or a combined tree, or supertree, to make its set of tips, and the subgrouping of those tips, conform to the set of lects that a typologist is analysing in a typological study.</p>
</div>
</div>
<div id="add-lengths" class="section level2" number="3.4">
<h2 number="3.4"><span class="header-section-number">3.4</span> How to add branch lengths</h2>
<p>Branch lengths in a tree convey information, and most phylogenetic comparative methods, including genealogically-sensitive averages and proportions, are sensitive to the information represented by the branch lengths. (To be specific, genealogically-sensitive averages and proportions are sensitive to the <em>relative</em> lengths of the branches, so multiplying all of the branch lengths in a tree by some constant amount would not affect the results.)</p>
<p>Glottolog’s trees contain informative subgrouping structure, but the branch lengths are all equal. Even without knowing what the true branch lengths are for a linguistic tree, we do know that a situation in which all are equal is highly unlikely. A good approximation to the most-likely<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> distribution of branch lengths in a phylogenetic tree, under a variety of assumptions, is exponential <span class="citation">(Venditti, Meade, and Pagel <a href="#ref-venditti2010phylogenies" role="doc-biblioref">2010</a>)</span>, i.e., very long branches are rare, and very short ones are frequent. This notion is implemented in the <code>glottoTrees</code> package by the function <code>rescale_branches_exp()</code>, which sets the deepest branches to length 1/2, then next layer to length 1/4, then the next to 1/8 and so on. This will produce a more plausible set of branch lengths, even in the absence of firm knowledge of exact lengths, and on these grounds we advocate its use if additional information about branch lengths is not available.</p>
<p>Here is an example of the result of applying exponential branch lengths to glottolog’s Great Andamanese tree:</p>
<pre class="r"><code>tree_GAp &lt;- rescale_branches_exp(tree_GA_abr)
plot_glotto(tree_GAp)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-55-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Here is an example of the result of applying them to glottolog’s Eskimo-Aleut tree, of 30 tips:</p>
<pre class="r"><code>tree_EA &lt;- get_glottolog_trees(&quot;Eskimo-Aleut&quot;)
tree_EA_abr &lt;- abridge_labels(tree_EA)
tree_EAa &lt;- rescale_branches_exp(tree_EA_abr)
plot_glotto(tree_EAa, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-56-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>An additional option is to stretch the terminal branches so that all tips are equidistant from the root, creating what is known as an <em>ultrametric</em> tree. This is done using the function <code>ultrametricize()</code>.</p>
<pre class="r"><code>tree_EAb &lt;- ultrametricize(tree_EAa)
plot_glotto(tree_EAb, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-57-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>An additional function, <code>rescale_deepest_branches()</code>, can be used to adjust just the deepest layer of branches. This may be useful where multiple family trees have been joined together, and there is a desire to manipulate the implied closeness or distance between the first-order branches. For example, here we take the hypothesised Arnhem group from Section @ref(combining-trees). First we assign exponential branch lengths with <code>set_branch_lengths_exp()</code>, which sets the deepest branch length to 1/2. Then we triple the distance of the deepest level of relationships by changing the first branch length to 1.5 using <code>rescale_deepest_branches()</code>, before ultrametricising the tree:</p>
<pre class="r"><code>tree_arnhem_a &lt;- rescale_branches_exp(tree_arnhem_abr)
tree_arnhem_b &lt;- rescale_deepest_branches(tree_arnhem_a, 1.5)
tree_arnhem_c &lt;- ultrametricize(tree_arnhem_b)
plot_glotto(tree_arnhem_c, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-58-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="exporting" class="section level2" number="3.5">
<h2 number="3.5"><span class="header-section-number">3.5</span> Exporting trees for use with other software</h2>
<p>In R, trees can be saved to file in Newick format using the function <code>write.tree()</code> in the <code>ape</code> package. Files like this can be opened by other software such as FigTree<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>, which can be used to interactively generate tree plots that may be useful for publication and dissemination. For instance, here we write the tree <code>tree_arnhem_c</code> to a file whose filename ends in the standard file extension, <code>.tree</code>:</p>
<pre class="r"><code>write.tree(tree_arnhem_c, &quot;my_arnhem_tree.tree&quot;)</code></pre>
<p>Often it will be desirable to reproduce a tree with labels that are more reader-friendly than glottocodes. <code>glottoTrees</code> provides the function <code>relabel_with_names()</code>, which will replace full glottolog labels, or labels consisting of just a glottocode, with glottolog’s corresponding language, dialect, subgroup or family name. Here we relabel the Arnhem tree by the languages’ names. As was the case with <code>abridge_labels()</code>, warnings are given by <code>relabel_with_names()</code> if a tree contains any nodes that cannot be relabeled in this way; these are not errors, just alerts.</p>
<pre class="r"><code>tree_arnhem_c_namelabels &lt;- relabel_with_names(tree_arnhem_c)</code></pre>
<pre><code>## Warning in relabel_with_names(tree_arnhem_c): Labels without glottocodes were
## detected and left unchanged for: 0 tip(s); 1 node(s):</code></pre>
<pre class="r"><code>plot_glotto(tree_arnhem_c_namelabels, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-60-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="example" class="section level1" number="4">
<h1 number="4"><span class="header-section-number">4</span> Putting it together: A worked example</h1>
<p>In this section we provide a real worked example of the use of the methods described above.</p>
<p><span class="citation">Yin (<a href="#ref-yin_violations_2020" role="doc-biblioref">2020</a>)</span> examined violations of the sonority sequencing principle in 496 languages, and calculated the genealogically-sensitive proportions of languages in which various violations occurred. The language sample consisted of 496 languages in the CLICS2 database <span class="citation">(Anderson et al. <a href="#ref-anderson2018clics2" role="doc-biblioref">2018</a>)</span> and the AusPhon-Lexicon database <span class="citation">(Round <a href="#ref-round_ausphon-lexicon_2017" role="doc-biblioref">2017</a>)</span>. The language sample was not balanced in the traditional sense, and phylogenetic methods were used to help produce a principled interpretation of the data.</p>
<p>Yin’s raw data consisted of a table of languages’ names and glottocodes and indications of whether or not the languages had consonant clusters in word-initial onsets or word-final codas that contained sonority reversals, coded as 1 for yes and 0 for no. This dataset is provided with the <code>phyloWeights</code> package as a dataframe named <code>yin_2020_data</code> whose columns are <code>name</code>, <code>tip</code>, <code>has_onset_violation</code> and <code>has_coda_violation</code>. The first ten rows are shown here:</p>
<pre class="r"><code>head(yin_2020_data, n = 10)</code></pre>
<pre><code>##                name      tip has_onset_violation has_coda_violation
## 1            Abkhaz abkh1244                   1                  1
## 2              Abui abui1241                   0                  0
## 3           Achagua acha1250                   0                  1
## 4             Adang adan1251                   0                  1
## 5     Adnyamathanha adny1235                   0                  0
## 6            Adyghe adyg1241                   1                  1
## 7      Hokkaidoainu ainu1240                   0                  0
## 8             Alawa alaw1244                   1                  0
## 9  Standardalbanian alba1267                   1                  1
## 10            Aleut aleu1260                   1                  1</code></pre>
<div id="preparing-a-tree" class="section level2" number="4.1">
<h2 number="4.1"><span class="header-section-number">4.1</span> Preparing a tree</h2>
<p>The tree for Yin’s study was constructed from a glottolog supertree, using glottolog version 4.2. Yin’s supertree made use of glottolog’s macroareas. Since the language sample covered relatively few families in the Americas, a single group was used for South America and North America. Additionally, the only African language available in the sample was Arabic, so Africa and Eurasia were grouped together:</p>
<pre class="r"><code>yin_macro &lt;- list(c(&quot;South America&quot;, &quot;North America&quot;), c(&quot;Africa&quot;, &quot;Eurasia&quot;),
                  &quot;Papunesia&quot;, &quot;Australia&quot;)
supertree &lt;- assemble_supertree(macro_groups = yin_macro, glottolog_version = &quot;4.2&quot;)
supertree_abr &lt;- abridge_labels(supertree)</code></pre>
<pre><code>## Warning in abridge_labels(supertree): Labels without glottocodes were detected
## and left unchanged for: 0 tip(s); 5 node(s): World, SouthAmerica-NorthAmerica,
## Africa-Eurasia, Papunesia, Australia</code></pre>
<p>Five tips were cloned, in cases where Yin had data for two varieties corresponding to just one tip in the glottolog supertree:</p>
<pre class="r"><code>supertree_a &lt;- clone_tip(supertree_abr, subgroup = TRUE,
                         label = c(&quot;ayab1239&quot;, &quot;basu1242&quot;, &quot;biri1256&quot;,
                                   &quot;ikar1243&quot;, &quot;peri1265&quot;))
supertree_b &lt;- apply_duplicate_suffixes(supertree_a)</code></pre>
<p>Eight tips were added, in cases where for sister lects (A,B), glottolog placed A as a node above B. In such cases, in new tip A was placed below the existing glottolog node A:</p>
<pre class="r"><code>supertree_c &lt;- supertree_b
nodes_to_add_as_tips &lt;- c(&quot;alor1249&quot;, &quot;gami1243&quot;, &quot;guri1247&quot;, &quot;mand1415&quot;, 
                          &quot;sins1241&quot;, &quot;wang1291&quot;, &quot;warl1254&quot;, &quot;yand1253&quot;)
# Loop through these nodes, and use add_tip() to add the new tip:
for (node_i in nodes_to_add_as_tips) {
  supertree_c &lt;- add_tip(supertree_c, label = node_i, parent_label = node_i)
}</code></pre>
<p>From this supertree, the 496 languages in Yin’s dataset were kept. The internal node <code>mada1298</code> was collapsed, as were all non-branching internal nodes:</p>
<pre class="r"><code>supertree_d &lt;- keep_as_tip(supertree_c, label = yin_2020_data$tip)
supertree_e &lt;- collapse_node(supertree_d, label = &quot;mada1298&quot;)
supertree_f &lt;- collapse_node(supertree_e, label = nonbranching_nodes(supertree_e))</code></pre>
<p>Finally, branch lengths were assigned. Branches were first assigned exponential lengths. Then, in order to diminish the importance of the macro groups, the branches above them were shortened to a length of 1/40. The effect of this decision is that the implied distance between families in different macro groups is only marginally greater than between families within a single macro group.</p>
<pre class="r"><code>supertree_g &lt;- rescale_branches_exp(supertree_f) 
yin_2020_tree &lt;- rescale_deepest_branches(supertree_g, 1/40)</code></pre>
<p>The resulting tree appears as in Figure @ref(fig:yin-tree), which is plotted with the following code:</p>
<pre class="r"><code>full_names &lt;- yin_2020_data$name[match(yin_2020_tree$tip.label, yin_2020_data$tip)]
name_tree &lt;- yin_2020_tree
name_tree$tip.label &lt;- full_names
plot(ladderize(name_tree, right = FALSE), type = &quot;fan&quot;, 
     cex = 0.3, label.offset = 0.002, edge.width = 0.5)</code></pre>
<div class="figure" style="text-align: center">
<img src="phylo_files/figure-html/yin-tree-1.png" alt="Supertree of 496 languages used in Yin (2020)." width="960" />
<p class="caption">
Supertree of 496 languages used in Yin (2020).
</p>
</div>
</div>
<div id="preparing-the-dataframe-of-typological-data" class="section level2" number="4.2">
<h2 number="4.2"><span class="header-section-number">4.2</span> Preparing the dataframe of typological data</h2>
<p>In order to calculate phylogenetic weights and genealogically-sensitive proportions, in addition to the tree (or a set of trees) we require a dataframe with (a) one column <code>tip</code>, whose contents match the tip labels in the trees, and (b) other columns containing numerical data to be averaged. The dataframe <code>yin_2020_data</code> has a column <code>tip</code> and two columns of numerical data <code>has_onset_violation</code> and <code>has_coda_violation</code>, and thus it meets the requirements we need. It also contains a column, <code>names</code>, of non-numeric data. Columns of non-numeric data (other than <code>tip</code>) are ignored by <code>phylo_average()</code>, so we do not need to remove them.</p>
</div>
<div id="calculating-genealogically-sensitive-proportions" class="section level2" number="4.3">
<h2 number="4.3"><span class="header-section-number">4.3</span> Calculating genealogically-sensitive proportions</h2>
<p>The results are calculated using <code>phylo_average()</code>, setting its <code>phy</code> argument to the tree we have constructed, <code>yin_2020_tree</code>, and its <code>data</code> argument to the dataframe we have prepared, <code>yin_2020_data</code>. A warning is issued alerting us that the dataframe contains a non-numeric column that gets ignored:</p>
<pre class="r"><code>yin_2020_results &lt;- phylo_average(phy = yin_2020_tree, data = yin_2020_data)</code></pre>
<pre><code>## Warning in phylo_average(phy = yin_2020_tree, data = yin_2020_data): `data`
## contains non-numeric columns other than `tip`, which have been ignored: name.</code></pre>
<p>Results are in the format described in Section @ref(averages). In this case, we are using only one tree, so the results are brief. The genealogically-sensitive proportions according to the ACL and BM methods are the following.</p>
<pre class="r"><code>yin_2020_results$ACL_averages</code></pre>
<pre><code>##    tree has_onset_violation has_coda_violation
## 1 tree1           0.3711102           0.409806</code></pre>
<pre class="r"><code>yin_2020_results$BM_averages</code></pre>
<pre><code>##    tree has_onset_violation has_coda_violation
## 1 tree1           0.4014756          0.3847729</code></pre>
<p>The first ten rows of phylogenetic weights according to the ACL and BM methods are:</p>
<pre class="r"><code>head(yin_2020_results$ACL_weights, n = 10)</code></pre>
<pre><code>##                name      tip        tree1
## 1            Abkhaz abkh1244 0.0069858330
## 2              Abui abui1241 0.0012637162
## 3           Achagua acha1250 0.0002456679
## 4             Adang adan1251 0.0002197767
## 5     Adnyamathanha adny1235 0.0000637717
## 6            Adyghe adyg1241 0.0069858330
## 7      Hokkaidoainu ainu1240 0.0174645825
## 8             Alawa alaw1244 0.0019652742
## 9  Standardalbanian alba1267 0.0023699724
## 10            Aleut aleu1260 0.0085266857</code></pre>
<pre class="r"><code>head(yin_2020_results$BM_weights, n = 10)</code></pre>
<pre><code>##                name      tip        tree1
## 1            Abkhaz abkh1244 0.0049475265
## 2              Abui abui1241 0.0021424363
## 3           Achagua acha1250 0.0009109899
## 4             Adang adan1251 0.0009391784
## 5     Adnyamathanha adny1235 0.0008929209
## 6            Adyghe adyg1241 0.0049475265
## 7      Hokkaidoainu ainu1240 0.0064304759
## 8             Alawa alaw1244 0.0027423594
## 9  Standardalbanian alba1267 0.0040995307
## 10            Aleut aleu1260 0.0055527679</code></pre>
<p>As a point of comparison, the raw proportions, which are equal to the means of the columns <code>has_onset_violation</code> and <code>has_coda_violation</code>, are these:</p>
<pre class="r"><code>mean(yin_2020_data$has_onset_violation)</code></pre>
<pre><code>## [1] 0.3649194</code></pre>
<pre class="r"><code>mean(yin_2020_data$has_coda_violation)</code></pre>
<pre><code>## [1] 0.3145161</code></pre>
</div>
</div>
<div id="using-these-methods-in-typological-research" class="section level1" number="5">
<h1 number="5"><span class="header-section-number">5</span> Using these methods in typological research</h1>
<p>As we seek to analyse the empirical diversity of attested languages, there are fundamental reasons why genealogy must be part of picture <span class="citation">(see Macklin-Cordes and Round <a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">2021</a><a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">a</a>)</span>. And since the genealogies of human languages are still incompletely known, it is imperative to make our phylogenetic hypotheses and assumptions as explicit and as testable as possible. In this document, we hope have shown that doing so is entirely feasible.</p>
<p>Through the use of <code>glottoTrees</code> and <code>phyloWeights</code>, we hope that in the future, linguistic trees and the code used to produce them can be published together with typological studies. This will enable subsequent researchers to replicate the study’s findings, and just as importantly, to modify its assumptions by modifying the trees, and thereby to test further hypotheses inspired by the initial research.</p>
<p>If you find these practical tools useful in your own research, please cite the packages as <span class="citation">E. R. Round (<a href="#ref-glottoTrees" role="doc-biblioref">2021</a><a href="#ref-glottoTrees" role="doc-biblioref">a</a>)</span> and <span class="citation">E. R. Round (<a href="#ref-phyloWeights" role="doc-biblioref">2021</a><a href="#ref-phyloWeights" role="doc-biblioref">b</a>)</span>. If you wish to cite the notion of genealogically-sensitive averages and proportions, please cite either <span class="citation">Macklin-Cordes and Round (<a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">2021</a><a href="#ref-macklin-cordes_challenges_nodate" role="doc-biblioref">a</a>)</span> and/or the more specific references therein.</p>
<p>If you think you’ve encountered a bug or anomalous behaviour in <code>glottoTrees</code> and <code>phyloWeights</code>, please be in contact, either through the package github pages or by email: <a href="mailto:e.round@uq.edu.au" class="email">e.round@uq.edu.au</a>. It’s important for the good of the science that linguists can use these methods without undue impediments.</p>
</div>
<div id="citation-session-info" class="section level1 unnumbered" number="">
<h1 class="unnumbered" number="">Citation &amp; Session Info</h1>
<p>Round, Erich. 2022. <em>Practical phylogenetic comparative methods for linguistic typology</em>. Surrey Morphology Group, University of Surrey &amp; Ancient Language Lab, University of Queensland. url: <a href="https://slcladal.github.io/phylo.html" class="uri">https://slcladal.github.io/phylo.html</a> (Version 2022.10.10).</p>
<pre><code>@manual{Round2022net,
  author = {Round, Erich},
  title = {Practical phylogenetic comparative methods for linguistic typology},
  note = {https://slcladal.github.io/phylo_for_typology.html},
  year = {2022},
  organization = {{Surrey Morphology Group, University of Surrey} and {Ancient Language Lab, School of Languages and Cultures, University of Queensland}},
  address = {{Guildford, UK} and {St Lucia, QLD}},
  edition = {2022.10.10}
}</code></pre>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 4.2.1 (2022-06-23)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 22.04.1 LTS
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0
## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0
## 
## locale:
##  [1] LC_CTYPE=en_AU.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_AU.UTF-8        LC_COLLATE=en_AU.UTF-8    
##  [5] LC_MONETARY=en_AU.UTF-8    LC_MESSAGES=en_AU.UTF-8   
##  [7] LC_PAPER=en_AU.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_AU.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices datasets  utils     methods   base     
## 
## other attached packages:
##  [1] ape_5.6-2             glottoTrees_0.1.0008  phyloWeights_0.3.0005
##  [4] flextable_0.7.3       forcats_0.5.1         stringr_1.4.0        
##  [7] dplyr_1.0.9           purrr_0.3.4           readr_2.1.2          
## [10] tidyr_1.2.0           tibble_3.1.7          ggplot2_3.3.6        
## [13] tidyverse_1.3.2      
## 
## loaded via a namespace (and not attached):
##  [1] nlme_3.1-158            fs_1.5.2                lubridate_1.8.0        
##  [4] httr_1.4.3              numDeriv_2016.8-1.1     tools_4.2.1            
##  [7] backports_1.4.1         bslib_0.3.1             utf8_1.2.2             
## [10] R6_2.5.1                DBI_1.1.3               colorspace_2.0-3       
## [13] withr_2.5.0             phangorn_2.9.0          tidyselect_1.1.2       
## [16] mnormt_2.1.0            compiler_4.2.1          cli_3.3.0              
## [19] rvest_1.0.2             expm_0.999-6            xml2_1.3.3             
## [22] officer_0.4.3           sass_0.4.1              scales_1.2.0           
## [25] quadprog_1.5-8          systemfonts_1.0.4       digest_0.6.29          
## [28] rmarkdown_2.14          base64enc_0.1-3         pkgconfig_2.0.3        
## [31] htmltools_0.5.2         plotrix_3.8-2           dbplyr_2.2.1           
## [34] fastmap_1.1.0           highr_0.9               maps_3.4.0             
## [37] rlang_1.0.4             readxl_1.4.0            jquerylib_0.1.4        
## [40] generics_0.1.3          combinat_0.0-8          jsonlite_1.8.0         
## [43] zip_2.2.0               googlesheets4_1.0.0     magrittr_2.0.3         
## [46] Matrix_1.4-1            Rcpp_1.0.8.3            munsell_0.5.0          
## [49] fansi_1.0.3             gdtools_0.2.4           lifecycle_1.0.1        
## [52] scatterplot3d_0.3-41    stringi_1.7.8           yaml_2.3.5             
## [55] clusterGeneration_1.3.7 MASS_7.3-58.1           grid_4.2.1             
## [58] parallel_4.2.1          crayon_1.5.1            lattice_0.20-45        
## [61] haven_2.5.0             hms_1.1.1               klippy_0.0.0.9500      
## [64] knitr_1.39              pillar_1.7.0            igraph_1.3.2           
## [67] uuid_1.1-0              codetools_0.2-18        fastmatch_1.1-3        
## [70] reprex_2.0.1            glue_1.6.2              evaluate_0.15          
## [73] data.table_1.14.2       renv_0.15.4             modelr_0.1.8           
## [76] vctrs_0.4.1             tzdb_0.3.0              cellranger_1.1.0       
## [79] gtable_0.3.0            assertthat_0.2.1        xfun_0.31              
## [82] broom_1.0.0             phytools_1.0-3          coda_0.19-4            
## [85] googledrive_2.0.0       gargle_1.2.0            ellipsis_0.3.2</code></pre>
<hr />
<p><a href="#introduction">Back to top</a></p>
<p><a href="https://slcladal.github.io/index.html">Back to HOME</a></p>
<hr />
</div>
<div id="references" class="section level1 unnumbered" number="">
<h1 class="unnumbered" number="">References</h1>
<div id="refs" class="references hanging-indent">
<div id="ref-altschul_weights_1989">
<p>Altschul, Stephen F., Raymond J. Carroll, and David J. Lipman. 1989. “Weights for Data Related by a Tree.” <em>Journal of Molecular Biology</em> 207 (4): 647–53.</p>
</div>
<div id="ref-anderson2018clics2">
<p>Anderson, Cormac, Robert Forkel, Simon J Greenhill, Johann-Mattis List, Christoph Rzymski, and Tiago Tresoldi. 2018. “CLICS2: An Improved Database of Cross-Linguistic Colexifications Assembling Lexical Data with the Help of Cross-Linguistic Data Formats.” <em>Linguistic Typology</em> 22 (2): 277–306.</p>
</div>
<div id="ref-Newick">
<p>Felsenstein, Joseph. n.d. <em>The Newick Tree Format</em>. <a href="http://evolution.genetics.washington.edu/phylip/newicktree.html">http://evolution.genetics.washington.edu/phylip/newicktree.html</a>.</p>
</div>
<div id="ref-green_proto_2003">
<p>Green, Rebecca. 2003. “Proto Maningrida with Proto Arnhem: Evidence from Verbal Inflectional Suffixes.” In <em>The Non-Pama-Nyungan Languages of Northern Australia : Comparative Studies of the Continent’s Most Linguistically Complex Region</em>, edited by Nicholas Evans, 369–421. Pacific Linguistics.</p>
</div>
<div id="ref-glottolog">
<p>Hammarström, Harald, Robert Forkel, Martin Haspelmath, and Sebastian Bank. 2021. <em>Glottolog 4.4</em>. Leipzig: Max Planck Institute for Evolutionary Anthropology. <a href="https://doi.org/10.5281/zenodo.4761960">https://doi.org/10.5281/zenodo.4761960</a>.</p>
</div>
<div id="ref-macklin-cordes_challenges_nodate">
<p>Macklin-Cordes, Jayden, and Erich R Round. 2021a. “Challenges of Sampling and How Phylogenetic Comparative Methods Help: With a Case Study of the Pama-Nyungan Laminal Contrast.”</p>
</div>
<div id="ref-macklin-cordes_phylogenetic_2021">
<p>———. 2021b. “Phylogenetic Comparative Methods: What All the Fuss Is About, and How to Use Them in Everyday Research.” Brisbane.</p>
</div>
<div id="ref-round_ausphon-lexicon_2017">
<p>Round, Erich R. 2017. “The AusPhon-Lexicon Project: 2 Million Normalized Segments Across 300 Australian Languages.”</p>
</div>
<div id="ref-glottoTrees">
<p>———. 2021a. <em>glottoTrees: Phylogenetic Trees in Linguistics.</em> <a href="https://github.com/erichround/glottoTrees">https://github.com/erichround/glottoTrees</a>.</p>
</div>
<div id="ref-phyloWeights">
<p>———. 2021b. <em>phyloWeights: Calculation of Genealogically-Sensitive Proportions and Averages</em>. <a href="https://github.com/erichround/phyloWeights">https://github.com/erichround/phyloWeights</a>.</p>
</div>
<div id="ref-stone_constructing_2007">
<p>Stone, Eric A., and Arend Sidow. 2007. “Constructing a Meaningful Evolutionary Average at the Phylogenetic Center of Mass.” <em>BMC Bioinformatics</em> 8 (1): 222.</p>
</div>
<div id="ref-venditti2010phylogenies">
<p>Venditti, Chris, Andrew Meade, and Mark Pagel. 2010. “Phylogenies Reveal New Interpretation of Speciation and the Red Queen.” <em>Nature</em> 463 (7279): 349–52.</p>
</div>
<div id="ref-yin_violations_2020">
<p>Yin, Ruihua. 2020. “Violations of the Sonority Sequencing Principle: How, and How Often?” <a href="https://als.asn.au/Conference/Program">https://als.asn.au/Conference/Program</a>.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>See online documentation of the <code>ape</code> package for reading trees from various common file formats.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Although this file is named <code>tree_glottolog_newick.txt</code>, it is not in true Newick format due to its use of square brackets in node and tip labels <span class="citation">(Felsenstein, <a href="#ref-Newick" role="doc-biblioref">n.d.</a>)</span>. In <code>glottoTrees</code>, the square brackets in glottolog’s file are converted to angled brackets (i.e., greater-than and less-than symbols), to bring them into conformity with the Newick standard.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>There are two exceptional glottocodes with numbers in the initial four characters: b10b1234 and 3adt1234.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>The differences are systematic and are made in order to conform with the permissible Newick format of tree labels: spaces and apostrophes are removed, parentheses are replaced by braces, and commas are replaced by forward slashes.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p><code>glottoTrees</code> currently contains information from glottolog versions 4.0, 4.1, 4.2, 4.3 and 4.4 (which is current at time of writing). Our intention is to update <code>glottoTrees</code> as glottolog updates in the future.<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>Converting nodes into tips may cause them to move to the left or right in the tree plot. The movement is meaningless, since a subgroup (A, B) is exactly the same as subgroup (B, A). Since the movement is meaningless, it’s also harmless.<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p><code>apply_duplicate_suffixes()</code> will also add suffixes to any nodes with duplicate labels.<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>‘Most likely’ doesn’t mean that we expect to see trees with exactly these branch lengths. Compare this to flipping a coin two million times: although it is unlikely that the outcome will be exactly one million heads and one million tails, it remains true that one million heads and one million tails is the most likely outcome, in the strict sense that it is more likely than any other outcome. The branch lengths discussed here are ‘most likely’ is a similar sense.<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p><a href="https://github.com/rambaut/figtree/releases" class="uri">https://github.com/rambaut/figtree/releases</a><a href="#fnref9" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
