<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Erich Round" />

<meta name="date" content="2022-07-30" />

<title>Practical phylogenetic methods for linguistic typology</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<link rel="stylesheet" href="styles.css" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VSGK4KYDQZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VSGK4KYDQZ');
</script>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">



<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  
  <!-- Added by SKC - LADAL image and thicker top with   -->
  <div class="container-fluid navbar-top" >
    <a href="index.html"> <!-- Make entire top row and text clickable home link  -->
        <div class="row">
            <div class="navbar-brand col-md-12">
              <img src="ladal_icon_cas_tran_white_trimed.png" class="navbar-icon" alt="LADAL"/>
              <span class="navbar-title-note navbar-collapse collapse" >Language Technology and Data Analysis Laboratory</span>
            </div>
        </div>
    </a>
  </div>
  
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <!-- SKC removed  navbar brand -->
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">HOME</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    ABOUT LADAL
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="people.html">People | Collabs</a>
    </li>
    <li>
      <a href="news.html">News</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    EVENTS
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="workshops.html">Workshops</a>
    </li>
    <li>
      <a href="compthink.html">Computational Thinking in HASS</a>
    </li>
    <li>
      <a href="webinars2022.html">LADAL Webinar Series 2022</a>
    </li>
    <li>
      <a href="opening.html">LADAL Webinar Series 2021</a>
    </li>
    <li>
      <a href="atapevents.html">ATAP Events</a>
    </li>
  </ul>
</li>
<li>
  <a href="tutorials.html">TUTORIALS</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    RESOURCES
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="links.html">Links</a>
    </li>
    <li>
      <a href="base.html">Tutorial stylesheet</a>
    </li>
  </ul>
</li>
<li>
  <a href="contact.html">CONTACT</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Practical phylogenetic methods for
linguistic typology</h1>
<h4 class="author">Erich Round</h4>
<h4 class="date">2022-07-30</h4>

</div>


<p><img src="https://slcladal.github.io/images/uq1.jpg" width="100%" /></p>
<div id="introduction" class="section level1 unnumbered">
<h1 class="unnumbered">Introduction</h1>
<p>A perennial task in typology is the characterization of frequencies
of traits of interest among the world’s languages. The scientific
interest of such questions typically lies not merely in the contingent
facts of today’s particular languages and language families, rather the
goal is to characterize the nature of human language in general, using
today’s contingent empirical data as evidence. One of the key challenges
that makes this task difficult to carry out in a principled way is that
languages are historically related to each other. This document is a
practical introduction to the use of <em>phylogenetic comparative
methods</em>, which will help to meet this challenge in a principled
way.</p>
<p><strong>Preparation and session set up</strong></p>
<p>This tutorial is based on R. If you have not installed R or are new
to it, you will find an introduction to and more information how to use
R <a href="https://slcladal.github.io/intror.html">here</a>. For this
tutorials, we need to install certain <em>packages</em> from an R
<em>library</em> so that the scripts shown below are executed without
errors. Before turning to the code in subsequent sections, please first
install the packages by running the code below this paragraph. If you
have already installed the packages mentioned below, then you can skip
ahead and ignore this section. To install the necessary packages, simply
run the following code - it may take some time (between 1 and 5 minutes
to install all of the libraries so you do not need to worry if it takes
some time).</p>
<pre class="r"><code># set options
options(stringsAsFactors = F)         # no automatic data transformation
options(&quot;scipen&quot; = 100, &quot;digits&quot; = 4) # suppress math annotation
# install packages
install.packages(&quot;tidyverse&quot;)
install.packages(&quot;flextable&quot;)
install.packages(&quot;devtools&quot;)
#install.packages(&quot;phytools&quot;)
install.packages(&quot;phangorn&quot;)
# install klippy for copy-to-clipboard button in code chunks
devtools::install_github(&quot;rlesur/klippy&quot;)
devtools::install_github(&quot;erichround/phyloWeights&quot;, 
                         dependencies = T, 
                         INSTALL_opts = c(&quot;--no-multiarch&quot;))
devtools::install_github(&quot;erichround/glottoTrees&quot;, 
                         dependencies = T, 
                         INSTALL_opts = c(&quot;--no-multiarch&quot;))</code></pre>
<p>Next, we activate the packages.</p>
<pre class="r"><code># activate packages
library(tidyverse)
library(flextable)
library(phyloWeights)
library(glottoTrees)
library(ape)
# activate klippy for copy-to-clipboard button
klippy::klippy()</code></pre>
<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('left', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<p>Once you have installed R, RStudio, and have also initiated the
session by executing the code shown above, you are good to go.</p>
<div id="an-intuitive-introduction-to-the-challenge-of-genealogy"
class="section level2 unnumbered">
<h2 class="unnumbered">An intuitive introduction to the challenge of
genealogy</h2>
<p>To get an intuitive notion of the challenge that is presented by the
genealogical relatedness of languages, consider the small language
family pictured in the figure below. It contains four languages, which
are either SOV or SVO. The question is: What proportion of this family
is SOV? Should you just count the languages, in which case the answer is
literally 75%? This answer may seem not quite right, because now one
half of the family is counting three times as much as the other half,
just because it had the fortune of containing more languages. Put
another way, the figure of 75% is strongly influenced by contingencies
of history.</p>
<p><img src="phylo_files/figure-html/SOV-tree-1.png" width="672" /></p>
<p>In a LADAL seminar on 4 November, 2021 <span class="citation">(<a
href="#ref-macklin-cordes_phylogenetic_2021"
role="doc-biblioref">Macklin-Cordes and Round 2021b</a>)</span> and in a
related journal article <span class="citation">(<a
href="#ref-macklin-cordes_challenges_nodate"
role="doc-biblioref">Macklin-Cordes and Round 2021a</a>)</span>, Jayden
Macklin-Cordes and I review some of history of thinking in linguists’
attempts to account for historical relatedness of exactly this kind when
comparing across languages. We also explain how <em>phylogenetic
comparative methods</em> present the most principled response to it
developed so far. We recommend reviewing either of these sources, since
they cover the scientific content which corresponds to the practical,
technical content in this tutorial. Here, we will not review the
scientific content at any length.</p>
<p>This document provides a guide to the practical use of phylogenetic
comparative methods for linguistic typology, specifically, the
calculation of genealogically-sensitive proportions and averages. These
are methods which provide an answer to the question: “When
characterising the frequencies of traits among the world’s languages,
how can we take genealogy into account?” Here we cover two methods for
calculating genealogically-sensitive proportions and averages: the ‘ACL’
method <span class="citation">(<a href="#ref-altschul_weights_1989"
role="doc-biblioref">Altschul, Carroll, and Lipman 1989</a>)</span> and
the ‘BM’ method <span class="citation">(<a
href="#ref-stone_constructing_2007" role="doc-biblioref">Stone and Sidow
2007</a>)</span>.</p>
<p>Because a key part of this kind of analysis is the preparation of a
phylogenetic tree, an important component of the tutorial will be about
how such trees can be prepared.</p>
<p>The tutorial is divided into four main sections. Section <a
href="#Trees-in-R">Trees in R</a> is an introduction to how trees are
represented in R. Section <a
href="#Genealogically-sensitive-averages-and-proportions">Genealogically-sensitive
averages and proportions</a> discusses the calculation of
genealogically-sensitive proportions and averages. Section <a
href="#Using-and-adapting-trees-from-glottolog.com">Using and adapting
trees from glottolog.com</a> explains how typologists can prepare
phylogenetic trees by adapting resources freely available from
glottolog.com <span class="citation">(<a href="#ref-glottolog"
role="doc-biblioref">Hammarström et al. 2021</a>)</span>. And Section <a
href="#Putting-it-together:-A-worked-example">Putting it together: A
worked example</a> provides a worked example used in a typological
investigation of sonority sequencing by <span class="citation">Yin (<a
href="#ref-yin_violations_2020"
role="doc-biblioref">2020</a>)</span>.</p>
<p>Much of the discussion below is an introduction to the functionality
of two R packages, <code>glottoTrees</code> <span class="citation">(<a
href="#ref-glottoTrees" role="doc-biblioref">Round 2021a</a>)</span> and
<code>phyloWeights</code> <span class="citation">(<a
href="#ref-phyloWeights" role="doc-biblioref">Round 2021b</a>)</span>,
which have been specifically written for these tasks. The text of this
tutorial is taken largely from the Supplementary Materials section S1 of
<span class="citation">Macklin-Cordes and Round (<a
href="#ref-macklin-cordes_challenges_nodate"
role="doc-biblioref">2021a</a>)</span>.</p>
<!-- This document represents an empty R Markdown file (or Rmd file) for a LADAL tutorial. The R Markdown document for this tutorial can be downloaded [here](https://slcladal.github.io/base.Rmd). -->
<!-- You will also have to download the bibliography file from https://slcladal.github.io/bibliography.bib for the tutorial to be knitted correctly. Although the knitted (or rendered) html file will look different from the LADAL design (because we have modified the theme for the LADAL page), it will be just like a proper LADAL tutorial once we have knitted the Rmd file on our machines and integrated your tutorial into the LADAL website. -->
</div>
</div>
<div id="r-trees" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Trees in R</h1>
<p>This section discusses how trees are created, manipulated and plotted
in R. Terminology we will use includes: <em>tips</em> at the ends of
trees, which in a linguistic tree would usually be the languages or
lects; the <em>branches</em> of a tree; the <em>interior nodes</em> or
just <em>nodes</em> of a tree, where branches join together; and the
<em>root</em> of the tree, its deepest node. R will represent trees as
complex objects, in which the tips, nodes and branches all appear, along
with labels for the tips and nodes.</p>
<p>One of the simplest methods of constructing a tree in R begins with a
description of the tree using a form a bracketing notation known as the
<em>Newick</em> standard <span class="citation">(<a href="#ref-Newick"
role="doc-biblioref">Felsenstein, n.d.</a>)</span>. In its simplest
form, a tree is represented in Newick format by a set of tip labels
grouped by parentheses, separated by commas, and ending with a
semicolon. For example, here is a string that represents a tree with
four tips, <code>A</code>, <code>B</code>, <code>C</code> and
<code>D</code>, which we assign to the object
<code>my_newick</code>:</p>
<pre class="r"><code>my_newick &lt;- &quot;(((A,B),C),D);&quot;</code></pre>
<p>A Newick-formatted string can then be converted to a tree object by
supplying it as the <code>text</code> argument of the function
<code>read.tree()</code>, from the <code>ape</code> package:</p>
<pre class="r"><code>my_tree &lt;- read.tree(text = my_newick)</code></pre>
<p>We can plot the tree using the <code>plot()</code> function:</p>
<pre class="r"><code>plot(my_tree)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>By default, trees in R are plotted horizontally following the
convention in biology. The <code>glottoTrees</code> package provides a
function <code>plot_glotto()</code> which plots trees in a more typical,
downward-running linguistic format, as below.</p>
<pre class="r"><code>plot_glotto(my_tree)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-4-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The tree object <code>my_tree</code> which we defined above did not
include information about branch lengths. In Newick format, branch
lengths are written with a preceding colon and appear directly after a
language or the closing bracket for a subgroup:</p>
<pre class="r"><code>my_newick2 &lt;- &quot;(((A:4,B:4):1,C:5):3,D:8);&quot;</code></pre>
<p>Converting this to a tree object and plotting it:</p>
<pre class="r"><code>my_tree2 &lt;- read.tree(text = my_newick2)
plot_glotto(my_tree2)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-6-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Trees can have labels not only for their tips, but also for their
internal nodes. In linguistics, an internal node of a tree may be
interpreted taxonomically, as representing a subgroup and labeled
accordingly, or genealogically, as a proto-language from which the
subgroup descends and labeled accordingly. In Newick format, labels for
internal nodes are placed directly after a closing parenthesis. For
example, here we add labels that reflect a genealogical interpretation
of the nodes:</p>
<pre class="r"><code>my_newick3 &lt;- &quot;(((A:4,B:4)proto-AB:1,C:5)proto-ABC:3,D:8)proto-ABCD;&quot;
my_tree3 &lt;- read.tree(text = my_newick3)
plot_glotto(my_tree3)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Technically speaking, trees are represented by R as objects with a
customised class called <code>phylo</code>.</p>
<pre class="r"><code>class(my_tree3)</code></pre>
<pre><code>## [1] &quot;phylo&quot;</code></pre>
<p>A <code>phylo</code> object stores information about the tree
<em>topology</em> (i.e., its branching structure), the branch lengths,
and the labels of the tips and nodes. In R we often use the
<code>$</code> operator to access one object that is contained inside
another. For instance, the object <code>y</code> contained within the
larger object <code>x</code> would be referred to as <code>x$y</code>.
Here are some examples:</p>
<pre class="r"><code>my_tree3$edge.length</code></pre>
<pre><code>## [1] 3 1 4 4 5 8</code></pre>
<pre class="r"><code>my_tree3$tip.label</code></pre>
<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot;</code></pre>
<pre class="r"><code>my_tree3$node.label</code></pre>
<pre><code>## [1] &quot;proto-ABCD&quot; &quot;proto-ABC&quot;  &quot;proto-AB&quot;</code></pre>
<p>Another object class in R, related to the <code>phylo</code> class,
is the <code>multiPhylo</code> class. Objects of the
<code>multiPhylo</code> class are used to store multiple
<code>phylo</code> trees in a single, larger object.</p>
<pre class="r"><code>newick_a &lt;- &quot;(((A:4,B:4):1,C:5):3,D:8);&quot;
newick_b &lt;- &quot;((A:2,B:2):1,(C:1,D:1,E:1):2);&quot;
tree_a &lt;- read.tree(text = newick_a)
tree_b &lt;- read.tree(text = newick_b)
my_multiPhylo &lt;- c(tree_a, tree_b)
class(my_multiPhylo)</code></pre>
<pre><code>## [1] &quot;multiPhylo&quot;</code></pre>
<p>For reasons we won’t go into here, the <code>phylo</code> trees
inside a <code>multiPhylo</code> object are not accessed using the
<code>$</code> operator but using double square brackets. For example,
here we refer to the second tree inside the object
<code>my_multiPhylo</code> by writing
<code>my_multiPhylo[[2]]</code>:</p>
<pre class="r"><code>plot_glotto(my_multiPhylo[[2]])</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-11-1.png" width="85%" style="display: block; margin: auto;" /></p>
<p>Before concluding this section, a final word is in order about the
irrelevance of the left-to-right arrangement of trees. In a tree, there
is no meaningful difference between (A,B) and (B,A): in both, A and B
are sisters under a shared parent node. Similarly, these are all
equivalent: (A,B,C), (A,C,B), (B,A,C), (B,C,A), (C,A,B) and (C,B,A). And
likewise, these are all equivalent: (A,(B,C)), (A,(C,B)), ((B,C),A) and
((C,B),A).</p>
</div>
<div id="averages" class="section level1" number="2">
<h1><span class="header-section-number">2</span>
Genealogically-sensitive averages and proportions</h1>
<p>We now turn to the calculation of genealogically-sensitive
proportions and averages. To begin, consider these six trees, which
represent six different hypotheses about the genealogical relationships
between languages <code>A</code>, <code>B</code>, <code>C</code> and
<code>D</code>. Also plotted here are the languages’ dominant word
orders and their numbers of consonant phonemes.</p>
<p><img src="phylo_files/figure-html/unnamed-chunk-12-1.png" width="672" height="20%" /></p>
<p>Questions that we seek to answer are: what is the proportion of this
set of languages that is SOV?; and what is the average number of
consonant phonemes in this set of languages? Moreover, we want the
answers to be sensitive to genealogy, and we’re interested in how the
answers may vary according to which of these six genealogical hypotheses
is adopted.</p>
<p>Calculating genealogically-sensitive averages and proportions will
require two key components:</p>
<ol style="list-style-type: decimal">
<li>A <code>phylo</code> or <code>multiPhylo</code> object containing
one or more trees.</li>
<li>A dataframe, which (i) contains the typological data to be averaged
and (ii) relates that data to the tips of the trees.</li>
</ol>
<p>The <code>phylo</code> or <code>multiPhylo</code> object can be
manually defined, as described in Section <a href="#Trees-in-R">Trees in
R</a>, can be read from a file,<a href="#fn1" class="footnote-ref"
id="fnref1"><sup>1</sup></a> or it can be constructed by using and
adjusting materials freely available from glottolog.com, as described
below in Section <a
href="#Using-and-adapting-trees-from-glottolog.com">Using and adapting
trees from glottolog.com</a>. In this example, our six trees can be
manually defined using the code below, which places them inside a single
<code>multiPhylo</code> object named <code>multi_phylo_ABCD</code>:</p>
<pre class="r"><code>multiPhylo_ABCD &lt;- 
  c(read.tree(text = &quot;(((A:0.2,B:0.2,C:0.2):1.8,D:2):0.3);&quot;),
    read.tree(text = &quot;(((A:1,B:1,C:1):1,D:2):0.3);&quot;), 
    read.tree(text = &quot;(((A:1.8,B:1.8,C:1.8):0.2,D:2):0.3);&quot;), 
    read.tree(text = &quot;((((A:1,B:1):0.8,C:1.8):0.2,D:2):0.3);&quot;),
    read.tree(text = &quot;(((A:1.8,(B:1,C:1):0.8):0.2,D:2):0.3);&quot;),
    read.tree(text = &quot;(((A:1,B:1):1,(C:1.8,D:1.8):0.2):0.3);&quot;)
    )</code></pre>
<p>The dataframe can be manually defined or be read from a file. Perhaps
the easiest method is to read from a file that you have created and
saved in “CSV” (comma separated value) format. CSV files can be created
in commercial spreadsheet software like Excel, and then read by R using
the <code>read.csv()</code> function like this:</p>
<pre class="r"><code>my_dataframe &lt;- read.csv(&quot;my_csv_file.csv&quot;)</code></pre>
<p>The dataframe must contain one column named <code>tip</code> (note
that in R, names of columns and other objects are case sensitive) plus
at least one column containing numerical data. The contents of the
<code>tip</code> column must be the same as the tip labels of the
tree(s) in the <code>phylo</code> or <code>multiPhylo</code> object. The
contents of the numerical columns will depend on whether a proportion or
an average is desired. To calculate a proportion, fill a numerical
column with 1 if the language possesses the property and 0 if it does
not. To calculate an average, fill a numerical column with the values of
the variable for each language.</p>
<p>For this example, the dataframe required is defined in the code
below. In addition to the <code>tip</code> column, it contains two
numerical columns, <code>is_SOV</code> and <code>n_consonants</code>. As
good housekeeping, we recommend using column names of the form
<code>is_X</code> or <code>has_X</code> for columns that contain data
for proportions, and names of the form <code>n_X</code> for columns that
contain counts to be averaged.</p>
<pre class="r"><code>data_ABCD &lt;- data.frame(tip = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), 
                        is_SOV = c(1, 1, 1, 0), 
                        n_consonants = c(18, 20, 22, 40),
                        stringsAsFactors = FALSE)</code></pre>
<p>Genealogically-sensitive averages and proportions are obtained using
the <code>phyloWeights</code> function <code>phylo_average()</code>,
specifying its arguments <code>phy</code> and <code>data</code> as in
the example below. Here we have assigned the output of this function to
a new object <code>results_ABCD</code>. We recommend always assigning
the output of <code>phylo_average()</code> to an object. We will see
below how to extract from it the various parts of the results.</p>
<pre class="r"><code>results_ABCD &lt;- phylo_average(phy = multiPhylo_ABCD, data = data_ABCD)</code></pre>
<p>The function <code>phylo_average()</code> may take up to several
minutes to run if the tree is large, or many trees are provided. It will
return error messages if the inputs provided to it are not what is
required.</p>
<p>The results object will contain several parts, which can be accessed
using the <code>$</code> operator. In <code>$phy</code> will be the
tree(s) that were supplied and in <code>$data</code> will be the
dataframe that was supplied, e.g.:</p>
<pre class="r"><code>results_ABCD$data</code></pre>
<pre><code>##   tip is_SOV n_consonants
## 1   A      1           18
## 2   B      1           20
## 3   C      1           22
## 4   D      0           40</code></pre>
<p>In <code>$ACL_averages</code> is a dataframe containing the
genealogically-sensitive averages/proportions according to the ACL
method. The dataframe has one row per tree and one column for each of
the numerical columns in the <code>data</code> dataframe. Here you can
see how the answer to our questions changes as the hypotheses about the
tree changes.</p>
<pre class="r"><code>results_ABCD$ACL_averages</code></pre>
<pre><code>##    tree    is_SOV n_consonants
## 1 tree1 0.5172414     29.65517
## 2 tree2 0.6000000     28.00000
## 3 tree3 0.7142857     25.71429
## 4 tree4 0.6768559     26.63755
## 5 tree5 0.6768559     26.28821
## 6 tree6 0.7115385     25.92308</code></pre>
<p>In <code>$BM_averages</code> appear the genealogically-sensitive
averages or proportions obtained using the BM method:</p>
<pre class="r"><code>results_ABCD$BM_averages</code></pre>
<pre><code>##    tree    is_SOV n_consonants
## 1 tree1 0.5568599     28.86280
## 2 tree2 0.6952381     26.09524
## 3 tree3 0.7468354     25.06329
## 4 tree4 0.7256904     25.56443
## 5 tree5 0.7256904     25.40796
## 6 tree6 0.7288732     25.50704</code></pre>
<p>In terms of their inner workings, both methods work by assigning
weights to languages, and those weights then reflect how much each
language contributes to the final result. These weights can be found in
<code>$ACL_weights</code> and <code>$BM_weights</code>. You might like
to compare, for each tree, the weights for languages <code>A</code>,
<code>B</code>, <code>C</code>, <code>D</code> with the positions of the
languages in the tree, in order to get an idea of how the weights relate
to the tree shape.</p>
<pre class="r"><code>results_ABCD$ACL_weights</code></pre>
<pre><code>##   tip     tree1 tree2     tree3     tree4     tree5     tree6
## 1   A 0.1724138   0.2 0.2380952 0.1965066 0.2838428 0.2115385
## 2   B 0.1724138   0.2 0.2380952 0.1965066 0.1965066 0.2115385
## 3   C 0.1724138   0.2 0.2380952 0.2838428 0.1965066 0.2884615
## 4   D 0.4827586   0.4 0.2857143 0.3231441 0.3231441 0.2884615</code></pre>
<pre class="r"><code>results_ABCD$BM_weights</code></pre>
<pre><code>##   tip     tree1     tree2     tree3     tree4     tree5     tree6
## 1   A 0.1856200 0.2317460 0.2489451 0.2288579 0.2679747 0.2288732
## 2   B 0.1856200 0.2317460 0.2489451 0.2288579 0.2288579 0.2288732
## 3   C 0.1856200 0.2317460 0.2489451 0.2679747 0.2288579 0.2711268
## 4   D 0.4431401 0.3047619 0.2531646 0.2743096 0.2743096 0.2711268</code></pre>
<p>It is possible to save any of these dataframes to a file using the
<code>write.csv()</code> function, for example:</p>
<pre class="r"><code>write.csv(results_ABCD$ACL_averages, file = &quot;my_ACL_averages.csv&quot;)</code></pre>
</div>
<div id="glottolog" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Using and adapting
trees from glottolog.com</h1>
<p>As we have seen, using phylogenetic comparative methods, such as
methods for calculating genealogically-sensitive averages, requires us
to have one or more trees, expressing hypotheses about genealogical
relationships among the languages. In this section we address the
questions, where can linguists obtain their trees from?; and how can
linguists adapt those trees to reflect their own hypotheses about
language relatedness?</p>
<p>Our starting point is glottolog.com <span class="citation">(<a
href="#ref-glottolog" role="doc-biblioref">Hammarström et al.
2021</a>)</span>, a major online publication which contains many useful
resources for quantitative typology. The R package
<code>glottoTrees</code> <span class="citation">(<a
href="#ref-glottoTrees" role="doc-biblioref">Round 2021a</a>)</span> has
been written to help linguists make the most of these resources,
including by modifying them as they desire. This section covers the
glottolog data itself and the functionality of <code>glottoTrees</code>.
We introduce glottolog’s genealogical data in Section <a
href="#Glottolog&#39;s-genealogical-data">Glottolog’s genealogical
data</a>, discussing how to locate metadata about languages and families
of interest, and how to view glottolog’s linguistic family trees. Since
genealogically-sensitive averages and proportions require all of the
languages in the study to be linked in a tree, we then discuss how
glottolog’s individual trees can be combined into larger, composite
trees in Section @ref(combining-trees). Since typological studies will
often examine language varieties at a level of granularity that differs
from glottolog’s own, in Section <a href="#How-to-modify-trees">How to
modify trees</a> we discuss how to add and remove languages from trees.
In Section <a href="#How-to-add-branch-lengths">How to add branch
lengths</a> we discuss how to add branch lengths to trees, since branch
lengths are necessary for the calculation of genealogically-sensitive
averages and proportions. Section @ref(exporting) discusses how to
export trees for use with other software.</p>
<div id="glottolog-genealogical" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Glottolog’s
genealogical data</h2>
<p>Glottolog provides metadata about the world’s language varieties,
their division into language families and the hierarchical subgrouping
of languages inside those families. Naturally, there are many points of
contention in linguistics about what the world’s stock of languages and
dialects actually is, how it groups into families, and how the families
themselves are subgrouped. Glottolog provides one set of answers, and
structures them in a way which provides typologists with a basis for
carrying out changes to suit their own hypotheses. In later sections we
will see how this can be done. In this section we describe glottolog’s
own global linguistic metadata.</p>
<p>At time of writing, the current version of glottolog is v4.4. The
<code>glottoTrees</code> package contains a copy of the v4.4 metadata
covering language names, language identification codes, family names,
geographical groupings, and family trees. The original metadata files
that contain this information are currently available at <a
href="https://glottolog.org/meta/downloads"
class="uri">https://glottolog.org/meta/downloads</a>, where a file named
<code>tree_glottolog_newick.txt</code><a href="#fn2"
class="footnote-ref" id="fnref2"><sup>2</sup></a> contains glottolog’s
trees, and <code>languages_and_dialects_geo.csv</code> provides
geographical metadata.</p>
<p>Language metadata can be accessed using the <code>glottoTrees</code>
function <code>get_glottolog_languages()</code>. This function returns a
dataframe of close to twenty-six thousand rows. To view it in full, we
suggest saving it to a CSV file and opening it in spreadsheet software
such as Excel:</p>
<pre class="r"><code>language_metadata &lt;- get_glottolog_languages()
write.csv(language_metadata, &quot;language_metadata.csv&quot;)</code></pre>
<p>Here are the first ten rows:</p>
<pre class="r"><code>language_metadata &lt;- get_glottolog_languages()
head(language_metadata, n = 10)</code></pre>
<pre><code>##    glottocode isocodes       name name_in_tree position tree
## 1    3adt1234          3Ad-Tekles   3Ad-Tekles      tip  391
## 2    aala1237              Aalawa       Aalawa      tip   94
## 3    aant1238          Aantantara   Aantantara      tip   90
## 4    aari1238     &lt;NA&gt;       &lt;NA&gt;   Aari-Gayil     node   22
## 5    aari1239      aiw       Aari         Aari      tip   22
## 6    aari1240      aay     Aariya       Aariya     &lt;NA&gt;   NA
## 7    aasa1238      aas      Aasax        Aasax      tip  391
## 8    aasd1234            Aasdring     Aasdring      tip  269
## 9    aata1238           Aatasaara    Aatasaara      tip   90
## 10   abaa1238              Rngaba       Rngaba      tip  345
##                tree_name
## 1           Afro-Asiatic
## 2           Austronesian
## 3  NuclearTransNewGuinea
## 4            SouthOmotic
## 5            SouthOmotic
## 6                   &lt;NA&gt;
## 7           Afro-Asiatic
## 8          Indo-European
## 9  NuclearTransNewGuinea
## 10          Sino-Tibetan</code></pre>
<p>Listed here are glottolog’s languages, dialects, subgroups and
families. These entities are identified by a name, an ISO-639-3 code if
available (format: three letters) and a glottolog-specific
<em>glottocode</em> (format: four letters followed by four digits<a
href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>). Also
described is the entity’s relationship to a glottolog tree: the
representation of its name in the tree (which may differ slightly from
the name used elsewhere by glottolog<a href="#fn4" class="footnote-ref"
id="fnref4"><sup>4</sup></a>), its position (as tip or node), and the
tree’s number and name.</p>
<p>By default, the metadata functions in <code>glottoTrees</code>, such
as <code>get_glottolog_languages()</code>, will return information about
the most recent version of glottolog which the package contains. To
access older versions, supply the version number via the
<code>glottolog_version</code> argument:<a href="#fn5"
class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<pre class="r"><code>language_metadata_v4.3 &lt;- get_glottolog_languages(glottolog_version = &quot;4.3&quot;)
head(language_metadata_v4.3, n = 10)</code></pre>
<pre><code>##    glottocode isocodes       name name_in_tree position tree
## 1    3adt1234          3Ad-Tekles   3Ad-Tekles      tip  186
## 2    aala1237              Aalawa       Aalawa      tip  205
## 3    aant1238          Aantantara   Aantantara      tip  145
## 4    aari1238     &lt;NA&gt;       &lt;NA&gt;   Aari-Gayil     node   85
## 5    aari1239      aiw       Aari         Aari      tip   85
## 6    aari1240      aay     Aariya       Aariya     &lt;NA&gt;   NA
## 7    aasa1238      aas      Aasax        Aasax      tip  186
## 8    aasd1234            Aasdring     Aasdring      tip  179
## 9    aata1238           Aatasaara    Aatasaara      tip  145
## 10   abaa1238              Rngaba       Rngaba      tip  329
##                tree_name
## 1           Afro-Asiatic
## 2           Austronesian
## 3  NuclearTransNewGuinea
## 4            SouthOmotic
## 5            SouthOmotic
## 6                   &lt;NA&gt;
## 7           Afro-Asiatic
## 8          Indo-European
## 9  NuclearTransNewGuinea
## 10          Sino-Tibetan</code></pre>
<p>Briefer metadata about glottolog’s language families can be accessed
using the <code>glottoTrees</code> function
<code>get_glottolog_families()</code>. This returns a dataframe of 420
rows, so to view it in full, we also suggest saving it to a CSV file and
opening it in spreadsheet software. Here are the first ten rows:</p>
<pre class="r"><code>family_metadata &lt;- get_glottolog_families()
head(family_metadata, n = 10)</code></pre>
<pre><code>##    tree           tree_name n_tips n_nodes main_macroarea
## 1     1                 Yam     33      18      Papunesia
## 2     2     Mongolic-Khitan     66      25        Eurasia
## 3     3 Kol{PapuaNewGuinea}      2       1      Papunesia
## 4     4       Namla-Tofanma      2       1      Papunesia
## 5     5          Tanahmerah      1       1      Papunesia
## 6     6         Jarawa-Onge      2       1        Eurasia
## 7     7        Ta-Ne-Omotic     29      15         Africa
## 8     8              Pomoan     10       7  North America
## 9     9         WesternDaly     14       7      Australia
## 10   10           Yangmanic      3       1      Australia</code></pre>
<p>Glottolog v4.4 divides the world’s languages into 420 families,
including 138 isolates, and it provides a tree for each. Together, the
420 trees contain 8,209 internal nodes and 17,008 tips, many of which
represent varieties that would typically be considered dialects.
Geographically, glottolog assigns each language variety to one of six
<em>macroareas</em>: Africa, Australia, Eurasia, Papunesia, South
America or North America. The <code>glottoTrees</code> metadata includes
a column <code>main_macroarea</code>. This is the one macroarea which
contains more of the family’s language varieties than any other. We will
see how this information can be useful in Section
@ref(combining-trees).</p>
<p>Glottolog’s 420 family trees are stored in a <code>multiPhylo</code>
object named <code>glottolog_trees_v4.4</code>. For example, here is
glottolog’s representation of the Great Andamanese family, which is tree
340 within the object <code>glottolog_trees_v4.4</code>. For
readability, we plot this tree horizontally:</p>
<pre class="r"><code>tree_GA &lt;- glottolog_trees_v4.4[[340]]
plot(tree_GA, x.lim = c(-0.3, 14))</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-23-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>Just above, we obtained the tree for Great Andamanese by referring to
its tree number (340) in the <code>glottolog_trees_v4.4</code> object.
The package <code>glottoTrees</code> also provides a function
<code>get_glottolog_trees()</code> which enables trees to be obtained
using the glottolog name for their families, for instance:</p>
<pre class="r"><code>tree_GA &lt;- get_glottolog_trees(&quot;GreatAndamanese&quot;)
plot(tree_GA, x.lim = c(-0.3, 14))</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-24-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>If you know the name of one or more families and would like to now
the number of their trees, use <code>which_tree()</code>:</p>
<pre class="r"><code>which_tree(&quot;GreatAndamanese&quot;)</code></pre>
<pre><code>## GreatAndamanese 
##             340</code></pre>
<pre class="r"><code>which_tree(c(&quot;Turkic&quot;, &quot;Tupian&quot;, &quot;Tuu&quot;))</code></pre>
<pre><code>## Turkic Tupian    Tuu 
##    217     32     76</code></pre>
<p>Both <code>get_glottolog_trees()</code> and <code>which_tree()</code>
allow the usage of a <code>glottolog_version</code> argument, to refer
to older versions of glottolog. For instance, here are the tree numbers
of the same families in version 4.1:</p>
<pre class="r"><code>which_tree(&quot;GreatAndamanese&quot;, glottolog_version = &quot;4.1&quot;)</code></pre>
<pre><code>## GreatAndamanese 
##               6</code></pre>
<pre class="r"><code>which_tree(c(&quot;Turkic&quot;, &quot;Tupian&quot;, &quot;Tuu&quot;), glottolog_version = &quot;4.1&quot;)</code></pre>
<pre><code>## Turkic Tupian    Tuu 
##     66    297     80</code></pre>
<p>In glottolog’s trees, the tip labels are rather long, consisting of a
name followed by a glottocode in angled brackets, an ISO code in angled
brackets (if one exists) and possibly the string “-l-”. Node labels (not
shown in the tree above) have the same structure. The
<code>glottoTrees</code> function <code>abridge_labels()</code> will
shorten labels to just the glottocode, for example:</p>
<pre class="r"><code>tree_GA_abr &lt;- abridge_labels(tree_GA)
plot_glotto(tree_GA_abr)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-27-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The function <code>abridge_labels()</code> will issue a warning if
there are tip or node labels in which it is unable to identify a
glottocode. We will see an example of this shortly below.</p>
<p>In glottolog’s trees, the branches are all of equal length. We will
discuss how to assign more realistic branch lengths in Section <a
href="#How-to-add-branch-lengths">How to add branch lengths</a>.</p>
</div>
<div id="combining-trees" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> How to combine
trees</h2>
<p>As discussed <span class="citation">Macklin-Cordes and Round (<a
href="#ref-macklin-cordes_challenges_nodate"
role="doc-biblioref">2021a</a>)</span>, the comparison of languages
across language families unavoidably carries a commitment to a
genealogical hypothesis, even if that hypotheses is, tacitly, that all
families are equally (un)related. Given that making such hypotheses is
unavoidable, it will be most beneficial for progress in the field to
make them explicit. To enable typologists to explore genealogical
hypotheses and to make those hypotheses explicit,
<code>glottoTrees</code> provides tools for combining multiple glottolog
trees into one.</p>
<p>To begin with a small example, here we combine five glottolog
families to represent the hypothesised Arnhem group in northern
Australia <span class="citation">(<a href="#ref-green_proto_2003"
role="doc-biblioref">Green 2003</a>)</span>. First we create a
<code>multiPhylo</code> object containing the five glottolog language
families (Gunwinyguan, Mangarrayi-Maran, Maningrida, and the isolates
Kungarakany and Gaagudju):</p>
<pre class="r"><code>arnhem_family_names &lt;- 
  c(&quot;Gunwinyguan&quot;, &quot;Mangarrayi-Maran&quot;, &quot;Maningrida&quot;, &quot;Kungarakany&quot;, &quot;Gaagudju&quot;)
multiPhylo_arnhem &lt;- get_glottolog_trees(arnhem_family_names)</code></pre>
<p>The <code>glottoTrees</code> function <code>assemble_rake()</code>
enables the trees in a <code>multiPhylo</code> object to be assembled
into a single tree with a rake structure at its root. Here we apply
<code>assemble_rake()</code> to our <code>multiPhylo</code> object and
assign the resulting, single tree to the object
<code>tree_arnhem</code>.</p>
<pre class="r"><code>tree_arnhem &lt;- assemble_rake(multiPhylo_arnhem)</code></pre>
<p>For plotting, it will be convenient to shorten the labels in the tree
to just the glottocodes, using <code>abridge_labels()</code>. However,
the root node in our newly created tree <code>tree_arnhem</code> has no
label. Accordingly, the function <code>abridge_labels()</code> will
issue a warning, that it encountered one node without a glottocode. This
is not an error message, and <code>abridge_labels()</code> still
shortens all labels to glottocodes where it can; it is just flagging the
fact that it was not able to do so in all cases.</p>
<pre class="r"><code>tree_arnhem_abr &lt;- abridge_labels(tree_arnhem)</code></pre>
<pre><code>## Warning in abridge_labels(tree_arnhem): Labels without glottocodes were detected
## and left unchanged for: 0 tip(s); 1 node(s):</code></pre>
<p>Plotting the resulting tree enables us to inspect our newly created
Arnhem tree. Note how all five families are joined to the root in a
rake-like structure, without any additional subgrouping.</p>
<pre class="r"><code>plot_glotto(tree_arnhem_abr, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-29-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>It is possible to give a combined tree more structure, by using
<code>assemble_rake()</code> iteratively. For instance, suppose we
wished to hypothesise that Gunwinyguan, Mangarrayi-Maran and Maningrida
form their own subgroup. First, we create a <code>multiPhylo</code>
object containing those three trees, and combine it into a single rake
tree, which we call <code>tree_A</code>:</p>
<pre class="r"><code>multiPhylo_A &lt;- get_glottolog_trees(c(&quot;Gunwinyguan&quot;, &quot;Mangarrayi-Maran&quot;, &quot;Maningrida&quot;))
tree_A &lt;- assemble_rake(multiPhylo_A)</code></pre>
<p>Then we create the final tree by combining <code>tree_A</code> with
the two isolate family trees:</p>
<pre class="r"><code>multiPhylo_arnhem2 &lt;- c(tree_A, get_glottolog_trees(c(&quot;Kungarakany&quot;, &quot;Gaagudju&quot;)))
tree_arnhem2 &lt;- assemble_rake(multiPhylo_arnhem2)
tree_arnhem2_abr &lt;- abridge_labels(tree_arnhem2)</code></pre>
<pre><code>## Warning in abridge_labels(tree_arnhem2): Labels without glottocodes were
## detected and left unchanged for: 0 tip(s); 2 node(s): ,</code></pre>
<pre class="r"><code>plot_glotto(tree_arnhem2_abr, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-31-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Typological studies often examine languages from very many families.
To group all 420 families into a single ‘supertree’,
<code>glottoTrees</code> provides the function
<code>assemble_supertree()</code>. By default, the function returns a
supertree that divides first into glottolog’s six macroareas, with an
internal node for each, and directly below these macroarea nodes appear
all of the glottolog families, grouped by their
<code>main_macroarea</code> mentioned in Section <a
href="#Glottolog&#39;s-genealogical-data">Glottolog’s genealogical
data</a> above. This tree is enormous, so we do not plot it here. It is
obtained like this:</p>
<pre class="r"><code>my_supertree &lt;- assemble_supertree()</code></pre>
<p>The highest-level, macroarea groupings can also be controlled through
the function’s argument <code>macro_groups</code>. For instance, to
group all of the world’s families directly into a 420-pronged rake
structure, set <code>macro_groups = NULL</code>:</p>
<pre class="r"><code>my_supertree &lt;- assemble_supertree(macro_groups = NULL)</code></pre>
<p>It is also possible to group macroareas together, for example, to
combine North and South America into a single group. Grouping of
macroareas is achieved by setting the <code>macro_groups</code> argument
to a <em>list</em> whose items are the desired groups of macroareas.
Each group will then appear as one of the highest-level nodes of the
tree, and all of its families below it. For instance, to keep all of
glottolog’s macroareas separate, but to combine North and South America
into a single group, the following code would be used. First we define a
list, which we’ve called <code>my_list</code>, within which any
groupings containing more than one macroarea are represented as a
vector, using the <code>c()</code> function:</p>
<pre class="r"><code>my_list &lt;- list(&quot;Africa&quot;, &quot;Australia&quot;, &quot;Eurasia&quot;, &quot;Papunesia&quot;,
                c(&quot;South America&quot;, &quot;North America&quot;))</code></pre>
<p>We then use that list as the <code>macro_groups</code> argument of
<code>assemble_supertree()</code>:</p>
<pre class="r"><code>my_supertree &lt;- assemble_supertree(macro_groups = my_list)</code></pre>
<p>Taking a second example, to create a supertree containing only the
families whose <code>main_macroarea</code> is either Africa or Eurasia,
and to place Africa and Eurasia under separate, highest-level nodes, we
would use:</p>
<pre class="r"><code>my_list &lt;- list(&quot;Africa&quot;, &quot;Eurasia&quot;)
my_supertree &lt;- assemble_supertree(macro_groups = my_list)</code></pre>
</div>
<div id="filter-tips" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span> How to modify
trees</h2>
<p>There are several reasons why typologists may wish to use a tree that
departs from the glottolog trees. Most commonly, a typological study
will cover a set of languages that differs from the set of tips in any
single glottolog tree, either through the exclusion of some of the lects
that glottolog represents as tips or through the distinction of
additional lects. A third case that can arise is when glottolog places
one or more dialects at the tree’s tips and more a general, language
node above them. The typologist may have data that applies to the
language (an internal node) rather than the dialects (the tips), yet the
calculation of genealogically-sensitive averages and proportions
requires one’s typological variables to be related to the tips of trees,
not to internal nodes. In these cases and many others, the typologist
may wish to alter the glottolog tree to suit the purposes of the
research. The <code>glottoTrees</code> package supplies a set of
functions to aid in performing each of these tree manipulations. In this
section we introduce them and illustrate their use.</p>
<p>In the following examples, we will make use glottolog’s
representation of the Great Andamanese family, whose labels we shorten
to just the glottocodes using <code>abridge_labels()</code>:</p>
<pre class="r"><code>tree_GA &lt;- get_glottolog_trees(&quot;GreatAndamanese&quot;)
tree_GA_abr &lt;- abridge_labels(tree_GA)
plot_glotto(tree_GA_abr)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-37-1.png" width="70%" style="display: block; margin: auto;" /></p>
<div id="how-to-remove-tips" class="section level3" number="3.3.1">
<h3><span class="header-section-number">3.3.1</span> How to remove
tips</h3>
<p>Firstly, we illustrate the removal of tips from a tree. There are two
functions in <code>glottoTrees</code> for doing this. The function
<code>remove_tip()</code> works by specifying which tips are to be
removed, while the function <code>keep_tip()</code> works by specifying
which tips are to be retained. First we will remove three of the
original ten tips in the Great Andamanese tree. We do this by setting
the <code>label</code> argument of <code>remove_tip()</code> to a vector
containing the labels of the tips to be removed. Within the vector, the
labels can appear in any order.</p>
<pre class="r"><code>tree_GAa &lt;- remove_tip(tree_GA_abr, label = c(&quot;akab1249&quot;, &quot;akak1251&quot;, &quot;apuc1241&quot;))
plot_glotto(tree_GAa)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-38-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>In this next example, we remove the tips <code>akab1249</code> and
<code>akar1243</code>. These tips are the only tips that sit below the
internal node <code>sout2683</code>. This is significant, because it
triggers a convention in tree manipulation, that if all tips below a
node are removed, then the node is removed also. We see that here:</p>
<pre class="r"><code>tree_GAb &lt;- remove_tip(tree_GA_abr, label = c(&quot;akab1249&quot;, &quot;akar1243&quot;))
plot_glotto(tree_GAb)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-39-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We now illustrate the usage of the <code>glottoTrees</code> function
<code>keep_tip()</code>. Here we use it to retain six of the original
ten tips in the Great Andamanese. We do this by setting the
<code>label</code> argument to a vector containing the labels of the six
desired tips.</p>
<pre class="r"><code>tree_GAc &lt;- keep_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1251&quot;, &quot;akac1240&quot;,
                                            &quot;akak1252&quot;, &quot;apuc1241&quot;, &quot;okoj1239&quot;))
plot_glotto(tree_GAc)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-40-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>As before, if our use of <code>keep_tip()</code> results in a node
having all of the tips below it removed, then the node will also be
removed automatically. This is illustrated here, where the node
<code>boca1235</code> is removed automatically because neither of the
tips below it are kept:</p>
<pre class="r"><code>tree_GAd &lt;- keep_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1251&quot;, &quot;akak1252&quot;,
                                            &quot;apuc1241&quot;, &quot;okoj1239&quot;))
plot_glotto(tree_GAd)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-41-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-remove-tips-and-convert-nodes-to-tips"
class="section level3" number="3.3.2">
<h3><span class="header-section-number">3.3.2</span> How to remove tips
and convert nodes to tips</h3>
<p>As mentioned earlier, many of the tips in glottolog’s trees
correspond to dialects, with languages represented as nodes above the
dialectal tips. One usage case we foresee is that a typologist will wish
to study a set of language varieties, some of which correspond to
glottolog’s tips and some of which correspond to nodes. The
<code>glottoTrees</code> function <code>keep_as_tips()</code> takes an
argument <code>label</code> which can contain both tip labels and node
labels. Any tips will be kept, and any nodes will be converted into
tips, with all of the structure below them being removed. Be mindful
when using <code>keep_as_tips()</code> that it is not possible to both
convert a node into a tip and also retain the structure below it, such
as tips that it dominates. Here we keep the same tips as in the tree
above, while also converting the node <code>boca1235</code> into a
tip:<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<pre class="r"><code>tree_GAe &lt;- keep_as_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1251&quot;, &quot;akak1252&quot;,
                                               &quot;apuc1241&quot;, &quot;okoj1239&quot;, &quot;boca1235&quot;))
plot_glotto(tree_GAe)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-42-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>One workflow that we envision for <code>keep_as_tip()</code> is that
the typologist has prepared a CSV file, one of whose columns is named
<code>tip</code> and contains the glottocodes of all the language
varieties in the study. This CSV file can be loaded in R and assigned to
a dataframe, and then its <code>tip</code> column can be passed to
<code>keep_as_tip()</code> as the value of the <code>labels</code>
argument, like this:</p>
<pre class="r"><code>my_dataframe &lt;- read.csv(&quot;my_data_file.csv&quot;, stringsAsFactors = FALSE)
my_new_tree &lt;- keep_as_tip(my_old_tree, label = my_dataframe$tip)</code></pre>
<p>To just convert one or more nodes into tips, use
<code>convert_to_tip()</code>, as we do here to convert the nodes
<code>okol1242</code> and <code>sout2683</code> to tips:</p>
<pre class="r"><code>tree_GAf &lt;- convert_to_tip(tree_GA_abr, label = c(&quot;okol1242&quot;, &quot;sout2683&quot;))
plot_glotto(tree_GAf)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-44-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-remove-internal-nodes" class="section level3"
number="3.3.3">
<h3><span class="header-section-number">3.3.3</span> How to remove
internal nodes</h3>
<p>Sometimes, the removal of tips will cause one or more of the
remaining tips to sit below a node which dominates only it. This
reflects that fact that <code>remove_tip()</code>,
<code>keep_tip()</code> and <code>keep_as_tip()</code> all preserve the
original <em>depth</em> of any tips that remain in the tree (you may
like to confirm this by reviewing the plots above). Depending on the
researcher’s needs, this outcome may or may not be desirable. If it is
undesirable, then non-branching, internal nodes can be removed using the
<code>glottoTrees</code> function <code>collapse_node()</code>. For
instance, here we remove two of the non-branching nodes from the tree
<code>tree_GAc</code> above, by naming them in the <code>label</code>
argument of <code>collapse_node()</code>. In the resulting tree, these
nodes have been removed, thus reducing the depth of the tips below
them:</p>
<pre class="r"><code>tree_GAg &lt;- collapse_node(tree_GAc, label = c(&quot;boca1235&quot;, &quot;okol1242&quot;))
plot_glotto(tree_GAg)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-45-1.png" width="55%" style="display: block; margin: auto;" /></p>
<p>When deciding whether to collapse nodes, in can be handy to know
which nodes in a tree that have only one child below them. The function
<code>nonbranching_nodes()</code> will return a vector of all such
nodes, for example:</p>
<pre class="r"><code>nonbranching_nodes(tree_GAc)</code></pre>
<pre><code>## [1] &quot;okol1242&quot; &quot;boca1235&quot; &quot;jeru1239&quot; &quot;sout2683&quot;</code></pre>
<pre class="r"><code>nonbranching_nodes(tree_GAg)</code></pre>
<pre><code>## [1] &quot;jeru1239&quot; &quot;sout2683&quot;</code></pre>
<p>The function <code>collapse_node()</code> can also be used to alter a
subgrouping hypothesis, and specifically, to remove a layer of
subgrouping, converting a nested structure ((A,B),C) into a flat
structure (A,B,C). For instance, here we remove the
<code>okol1242</code> node of the original glottolog Great Andamanese
tree, converting its two daughter languages into sisters of
<code>okoj1239</code>:</p>
<pre class="r"><code>tree_GAh &lt;- collapse_node(tree_GA_abr, label= &quot;okol1242&quot;)
plot_glotto(tree_GAh)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-47-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-add-tips" class="section level3" number="3.3.4">
<h3><span class="header-section-number">3.3.4</span> How to add
tips</h3>
<p>The function <code>add_tip()</code> allows tips to be added to a
tree. The <code>label</code> argument specifies the name of the new tip,
while <code>parent_label</code> specifies the label of the node below
which the new tip should appear. Here we add a tip <code>xxxx1234</code>
below the node <code>sout2683</code>:</p>
<pre class="r"><code>tree_GAi &lt;- add_tip(tree_GA_abr, label = &quot;xxxx1234&quot;, parent_label = &quot;sout2683&quot;)
plot_glotto(tree_GAi)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-48-1.png" width="55%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-clone-tips" class="section level3" number="3.3.5">
<h3><span class="header-section-number">3.3.5</span> How to clone
tips</h3>
<p>Next we illustrate the cloning of tips. Cloning tips may be useful
when glottolog provides only one glottocode, and thus only one tree tip,
corresponding to multiple lects in the typologist’s study. To clone a
tip, use the function <code>clone_tip()</code> and in the
<code>label</code> argument, provide a vector of the tips to be cloned.
Here we clone tips <code>akar1243</code> and <code>akak1252</code>:</p>
<pre class="r"><code>tree_GAj &lt;- clone_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1252&quot;))
plot_glotto(tree_GAj)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-49-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>By default, clones are added to the tree as sisters directly beneath
the parent node of the original tip. An alternative is to create a new
subgroup for each set of sister clones, using the <code>subgroup</code>
argument and setting it to <code>subgroup = TRUE</code>. Each newly
created subgroup node is given a label that matches the cloned tips it
dominates:</p>
<pre class="r"><code>tree_GAk &lt;- clone_tip(tree_GA_abr, label = c(&quot;akar1243&quot;, &quot;akak1252&quot;), subgroup = TRUE)
plot_glotto(tree_GAk)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-50-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>It is also possible to make more than one clone using the
<code>n</code> argument. Here we create three new clones of
<code>akab1248</code> and place them in a subgroup:</p>
<pre class="r"><code>tree_GAl &lt;- clone_tip(tree_GA_abr, label = &quot;akab1248&quot;, n = 3, subgroup = TRUE)
plot_glotto(tree_GAl)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-51-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>One of the consequences of cloning tips is that the in the resulting
tree, not all tips will have distinct names. The function
<code>apply_duplicate_suffixes()</code> will add a suffix to any tips
with duplicate labels, to make them unique.<a href="#fn7"
class="footnote-ref" id="fnref7"><sup>7</sup></a> The suffix will
consist of a hyphen followed by a number. Here we add suffixes to the
tree <code>tree_GAj</code>:</p>
<pre class="r"><code>tree_GAm &lt;- apply_duplicate_suffixes(tree_GAj)
plot_glotto(tree_GAm)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-52-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-move-a-tip" class="section level3" number="3.3.6">
<h3><span class="header-section-number">3.3.6</span> How to move a
tip</h3>
<p>Using the function <code>move_tip()</code>, a tip can be moved to a
new position, beneath a new parent node (one of the nodes already in the
tree) which is specified with the <code>parent_label</code>
argument:</p>
<pre class="r"><code>tree_GAn &lt;- move_tip(tree_GA_abr, label = &quot;apuc1241&quot;, parent_label = &quot;jeru1239&quot;)
plot_glotto(tree_GAn)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-53-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-move-a-node-and-its-descendants" class="section level3"
number="3.3.7">
<h3><span class="header-section-number">3.3.7</span> How to move a node
and its descendants</h3>
<p>In a similar fashion, the function <code>move_node()</code> is used
to move an internal node, along with all of the structure below it, to a
position beneath a new parent node:</p>
<pre class="r"><code>tree_GAo &lt;- move_node(tree_GA_abr, label = &quot;jeru1239&quot;, parent_label = &quot;okol1242&quot;)
plot_glotto(tree_GAo)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-54-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="summary-a-general-purpose-toolkit-for-curating-trees-topology"
class="section level3" number="3.3.8">
<h3><span class="header-section-number">3.3.8</span> Summary: a
general-purpose toolkit for curating trees’ topology</h3>
<p>The functions <code>remove_tip()</code>, <code>keep_tip()</code>,
<code>keep_as_tip()</code>, <code>convert_to_tip()</code>,
<code>collapse_node()</code>, <code>add_tip()</code>,
<code>clone_tip()</code>, <code>move_tip()</code> and
<code>move_node()</code> provide a general-purpose toolkit for modifying
a single glottolog tree, or a combined tree, or supertree, to make its
set of tips, and the subgrouping of those tips, conform to the set of
lects that a typologist is analysing in a typological study.</p>
</div>
</div>
<div id="add-lengths" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> How to add branch
lengths</h2>
<p>Branch lengths in a tree convey information, and most phylogenetic
comparative methods, including genealogically-sensitive averages and
proportions, are sensitive to the information represented by the branch
lengths. (To be specific, genealogically-sensitive averages and
proportions are sensitive to the <em>relative</em> lengths of the
branches, so multiplying all of the branch lengths in a tree by some
constant amount would not affect the results.)</p>
<p>Glottolog’s trees contain informative subgrouping structure, but the
branch lengths are all equal. Even without knowing what the true branch
lengths are for a linguistic tree, we do know that a situation in which
all are equal is highly unlikely. A good approximation to the
most-likely<a href="#fn8" class="footnote-ref"
id="fnref8"><sup>8</sup></a> distribution of branch lengths in a
phylogenetic tree, under a variety of assumptions, is exponential <span
class="citation">(<a href="#ref-venditti2010phylogenies"
role="doc-biblioref">Venditti, Meade, and Pagel 2010</a>)</span>, i.e.,
very long branches are rare, and very short ones are frequent. This
notion is implemented in the <code>glottoTrees</code> package by the
function <code>rescale_branches_exp()</code>, which sets the deepest
branches to length 1/2, then next layer to length 1/4, then the next to
1/8 and so on. This will produce a more plausible set of branch lengths,
even in the absence of firm knowledge of exact lengths, and on these
grounds we advocate its use if additional information about branch
lengths is not available.</p>
<p>Here is an example of the result of applying exponential branch
lengths to glottolog’s Great Andamanese tree:</p>
<pre class="r"><code>tree_GAp &lt;- rescale_branches_exp(tree_GA_abr)
plot_glotto(tree_GAp)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-55-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Here is an example of the result of applying them to glottolog’s
Eskimo-Aleut tree, of 30 tips:</p>
<pre class="r"><code>tree_EA &lt;- get_glottolog_trees(&quot;Eskimo-Aleut&quot;)
tree_EA_abr &lt;- abridge_labels(tree_EA)
tree_EAa &lt;- rescale_branches_exp(tree_EA_abr)
plot_glotto(tree_EAa, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-56-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>An additional option is to stretch the terminal branches so that all
tips are equidistant from the root, creating what is known as an
<em>ultrametric</em> tree. This is done using the function
<code>ultrametricize()</code>.</p>
<pre class="r"><code>tree_EAb &lt;- ultrametricize(tree_EAa)
plot_glotto(tree_EAb, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-57-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>An additional function, <code>rescale_deepest_branches()</code>, can
be used to adjust just the deepest layer of branches. This may be useful
where multiple family trees have been joined together, and there is a
desire to manipulate the implied closeness or distance between the
first-order branches. For example, here we take the hypothesised Arnhem
group from Section @ref(combining-trees). First we assign exponential
branch lengths with <code>set_branch_lengths_exp()</code>, which sets
the deepest branch length to 1/2. Then we triple the distance of the
deepest level of relationships by changing the first branch length to
1.5 using <code>rescale_deepest_branches()</code>, before
ultrametricising the tree:</p>
<pre class="r"><code>tree_arnhem_a &lt;- rescale_branches_exp(tree_arnhem_abr)
tree_arnhem_b &lt;- rescale_deepest_branches(tree_arnhem_a, 1.5)
tree_arnhem_c &lt;- ultrametricize(tree_arnhem_b)
plot_glotto(tree_arnhem_c, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-58-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="exporting" class="section level2" number="3.5">
<h2><span class="header-section-number">3.5</span> Exporting trees for
use with other software</h2>
<p>In R, trees can be saved to file in Newick format using the function
<code>write.tree()</code> in the <code>ape</code> package. Files like
this can be opened by other software such as FigTree<a href="#fn9"
class="footnote-ref" id="fnref9"><sup>9</sup></a>, which can be used to
interactively generate tree plots that may be useful for publication and
dissemination. For instance, here we write the tree
<code>tree_arnhem_c</code> to a file whose filename ends in the standard
file extension, <code>.tree</code>:</p>
<pre class="r"><code>write.tree(tree_arnhem_c, &quot;my_arnhem_tree.tree&quot;)</code></pre>
<p>Often it will be desirable to reproduce a tree with labels that are
more reader-friendly than glottocodes. <code>glottoTrees</code> provides
the function <code>relabel_with_names()</code>, which will replace full
glottolog labels, or labels consisting of just a glottocode, with
glottolog’s corresponding language, dialect, subgroup or family name.
Here we relabel the Arnhem tree by the languages’ names. As was the case
with <code>abridge_labels()</code>, warnings are given by
<code>relabel_with_names()</code> if a tree contains any nodes that
cannot be relabeled in this way; these are not errors, just alerts.</p>
<pre class="r"><code>tree_arnhem_c_namelabels &lt;- relabel_with_names(tree_arnhem_c)</code></pre>
<pre><code>## Warning in relabel_with_names(tree_arnhem_c): Labels without glottocodes were
## detected and left unchanged for: 0 tip(s); 1 node(s):</code></pre>
<pre class="r"><code>plot_glotto(tree_arnhem_c_namelabels, nodelabels = FALSE)</code></pre>
<p><img src="phylo_files/figure-html/unnamed-chunk-60-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="example" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Putting it together: A
worked example</h1>
<p>In this section we provide a real worked example of the use of the
methods described above.</p>
<p><span class="citation">Yin (<a href="#ref-yin_violations_2020"
role="doc-biblioref">2020</a>)</span> examined violations of the
sonority sequencing principle in 496 languages, and calculated the
genealogically-sensitive proportions of languages in which various
violations occurred. The language sample consisted of 496 languages in
the CLICS2 database <span class="citation">(<a
href="#ref-anderson2018clics2" role="doc-biblioref">Anderson et al.
2018</a>)</span> and the AusPhon-Lexicon database <span
class="citation">(<a href="#ref-round_ausphon-lexicon_2017"
role="doc-biblioref">Round 2017</a>)</span>. The language sample was not
balanced in the traditional sense, and phylogenetic methods were used to
help produce a principled interpretation of the data.</p>
<p>Yin’s raw data consisted of a table of languages’ names and
glottocodes and indications of whether or not the languages had
consonant clusters in word-initial onsets or word-final codas that
contained sonority reversals, coded as 1 for yes and 0 for no. This
dataset is provided with the <code>phyloWeights</code> package as a
dataframe named <code>yin_2020_data</code> whose columns are
<code>name</code>, <code>tip</code>, <code>has_onset_violation</code>
and <code>has_coda_violation</code>. The first ten rows are shown
here:</p>
<pre class="r"><code>head(yin_2020_data, n = 10)</code></pre>
<pre><code>##                name      tip has_onset_violation has_coda_violation
## 1            Abkhaz abkh1244                   1                  1
## 2              Abui abui1241                   0                  0
## 3           Achagua acha1250                   0                  1
## 4             Adang adan1251                   0                  1
## 5     Adnyamathanha adny1235                   0                  0
## 6            Adyghe adyg1241                   1                  1
## 7      Hokkaidoainu ainu1240                   0                  0
## 8             Alawa alaw1244                   1                  0
## 9  Standardalbanian alba1267                   1                  1
## 10            Aleut aleu1260                   1                  1</code></pre>
<div id="preparing-a-tree" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Preparing a tree</h2>
<p>The tree for Yin’s study was constructed from a glottolog supertree,
using glottolog version 4.2. Yin’s supertree made use of glottolog’s
macroareas. Since the language sample covered relatively few families in
the Americas, a single group was used for South America and North
America. Additionally, the only African language available in the sample
was Arabic, so Africa and Eurasia were grouped together:</p>
<pre class="r"><code>yin_macro &lt;- list(c(&quot;South America&quot;, &quot;North America&quot;), c(&quot;Africa&quot;, &quot;Eurasia&quot;),
                  &quot;Papunesia&quot;, &quot;Australia&quot;)
supertree &lt;- assemble_supertree(macro_groups = yin_macro, glottolog_version = &quot;4.2&quot;)
supertree_abr &lt;- abridge_labels(supertree)</code></pre>
<pre><code>## Warning in abridge_labels(supertree): Labels without glottocodes were detected
## and left unchanged for: 0 tip(s); 5 node(s): World, SouthAmerica-NorthAmerica,
## Africa-Eurasia, Papunesia, Australia</code></pre>
<p>Five tips were cloned, in cases where Yin had data for two varieties
corresponding to just one tip in the glottolog supertree:</p>
<pre class="r"><code>supertree_a &lt;- clone_tip(supertree_abr, subgroup = TRUE,
                         label = c(&quot;ayab1239&quot;, &quot;basu1242&quot;, &quot;biri1256&quot;,
                                   &quot;ikar1243&quot;, &quot;peri1265&quot;))
supertree_b &lt;- apply_duplicate_suffixes(supertree_a)</code></pre>
<p>Eight tips were added, in cases where for sister lects (A,B),
glottolog placed A as a node above B. In such cases, in new tip A was
placed below the existing glottolog node A:</p>
<pre class="r"><code>supertree_c &lt;- supertree_b
nodes_to_add_as_tips &lt;- c(&quot;alor1249&quot;, &quot;gami1243&quot;, &quot;guri1247&quot;, &quot;mand1415&quot;, 
                          &quot;sins1241&quot;, &quot;wang1291&quot;, &quot;warl1254&quot;, &quot;yand1253&quot;)
# Loop through these nodes, and use add_tip() to add the new tip:
for (node_i in nodes_to_add_as_tips) {
  supertree_c &lt;- add_tip(supertree_c, label = node_i, parent_label = node_i)
}</code></pre>
<p>From this supertree, the 496 languages in Yin’s dataset were kept.
The internal node <code>mada1298</code> was collapsed, as were all
non-branching internal nodes:</p>
<pre class="r"><code>supertree_d &lt;- keep_as_tip(supertree_c, label = yin_2020_data$tip)
supertree_e &lt;- collapse_node(supertree_d, label = &quot;mada1298&quot;)
supertree_f &lt;- collapse_node(supertree_e, label = nonbranching_nodes(supertree_e))</code></pre>
<p>Finally, branch lengths were assigned. Branches were first assigned
exponential lengths. Then, in order to diminish the importance of the
macro groups, the branches above them were shortened to a length of
1/40. The effect of this decision is that the implied distance between
families in different macro groups is only marginally greater than
between families within a single macro group.</p>
<pre class="r"><code>supertree_g &lt;- rescale_branches_exp(supertree_f) 
yin_2020_tree &lt;- rescale_deepest_branches(supertree_g, 1/40)</code></pre>
<p>The resulting tree appears as in Figure @ref(fig:yin-tree), which is
plotted with the following code:</p>
<pre class="r"><code>full_names &lt;- yin_2020_data$name[match(yin_2020_tree$tip.label, yin_2020_data$tip)]
name_tree &lt;- yin_2020_tree
name_tree$tip.label &lt;- full_names
plot(ladderize(name_tree, right = FALSE), type = &quot;fan&quot;, 
     cex = 0.3, label.offset = 0.002, edge.width = 0.5)</code></pre>
<div class="figure" style="text-align: center">
<img src="phylo_files/figure-html/yin-tree-1.png" alt="Supertree of 496 languages used in Yin (2020)." width="960" />
<p class="caption">
Supertree of 496 languages used in Yin (2020).
</p>
</div>
</div>
<div id="preparing-the-dataframe-of-typological-data"
class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Preparing the
dataframe of typological data</h2>
<p>In order to calculate phylogenetic weights and
genealogically-sensitive proportions, in addition to the tree (or a set
of trees) we require a dataframe with (a) one column <code>tip</code>,
whose contents match the tip labels in the trees, and (b) other columns
containing numerical data to be averaged. The dataframe
<code>yin_2020_data</code> has a column <code>tip</code> and two columns
of numerical data <code>has_onset_violation</code> and
<code>has_coda_violation</code>, and thus it meets the requirements we
need. It also contains a column, <code>names</code>, of non-numeric
data. Columns of non-numeric data (other than <code>tip</code>) are
ignored by <code>phylo_average()</code>, so we do not need to remove
them.</p>
</div>
<div id="calculating-genealogically-sensitive-proportions"
class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Calculating
genealogically-sensitive proportions</h2>
<p>The results are calculated using <code>phylo_average()</code>,
setting its <code>phy</code> argument to the tree we have constructed,
<code>yin_2020_tree</code>, and its <code>data</code> argument to the
dataframe we have prepared, <code>yin_2020_data</code>. A warning is
issued alerting us that the dataframe contains a non-numeric column that
gets ignored:</p>
<pre class="r"><code>yin_2020_results &lt;- phylo_average(phy = yin_2020_tree, data = yin_2020_data)</code></pre>
<pre><code>## Warning in phylo_average(phy = yin_2020_tree, data = yin_2020_data): `data`
## contains non-numeric columns other than `tip`, which have been ignored: name.</code></pre>
<p>Results are in the format described in Section @ref(averages). In
this case, we are using only one tree, so the results are brief. The
genealogically-sensitive proportions according to the ACL and BM methods
are the following.</p>
<pre class="r"><code>yin_2020_results$ACL_averages</code></pre>
<pre><code>##    tree has_onset_violation has_coda_violation
## 1 tree1           0.3711102           0.409806</code></pre>
<pre class="r"><code>yin_2020_results$BM_averages</code></pre>
<pre><code>##    tree has_onset_violation has_coda_violation
## 1 tree1           0.4014756          0.3847729</code></pre>
<p>The first ten rows of phylogenetic weights according to the ACL and
BM methods are:</p>
<pre class="r"><code>head(yin_2020_results$ACL_weights, n = 10)</code></pre>
<pre><code>##                name      tip        tree1
## 1            Abkhaz abkh1244 0.0069858330
## 2              Abui abui1241 0.0012637162
## 3           Achagua acha1250 0.0002456679
## 4             Adang adan1251 0.0002197767
## 5     Adnyamathanha adny1235 0.0000637717
## 6            Adyghe adyg1241 0.0069858330
## 7      Hokkaidoainu ainu1240 0.0174645825
## 8             Alawa alaw1244 0.0019652742
## 9  Standardalbanian alba1267 0.0023699724
## 10            Aleut aleu1260 0.0085266857</code></pre>
<pre class="r"><code>head(yin_2020_results$BM_weights, n = 10)</code></pre>
<pre><code>##                name      tip        tree1
## 1            Abkhaz abkh1244 0.0049475265
## 2              Abui abui1241 0.0021424363
## 3           Achagua acha1250 0.0009109899
## 4             Adang adan1251 0.0009391784
## 5     Adnyamathanha adny1235 0.0008929209
## 6            Adyghe adyg1241 0.0049475265
## 7      Hokkaidoainu ainu1240 0.0064304759
## 8             Alawa alaw1244 0.0027423594
## 9  Standardalbanian alba1267 0.0040995307
## 10            Aleut aleu1260 0.0055527679</code></pre>
<p>As a point of comparison, the raw proportions, which are equal to the
means of the columns <code>has_onset_violation</code> and
<code>has_coda_violation</code>, are these:</p>
<pre class="r"><code>mean(yin_2020_data$has_onset_violation)</code></pre>
<pre><code>## [1] 0.3649194</code></pre>
<pre class="r"><code>mean(yin_2020_data$has_coda_violation)</code></pre>
<pre><code>## [1] 0.3145161</code></pre>
</div>
</div>
<div id="using-these-methods-in-typological-research"
class="section level1" number="5">
<h1><span class="header-section-number">5</span> Using these methods in
typological research</h1>
<p>As we seek to analyse the empirical diversity of attested languages,
there are fundamental reasons why genealogy must be part of picture
<span class="citation">(see <a
href="#ref-macklin-cordes_challenges_nodate"
role="doc-biblioref">Macklin-Cordes and Round 2021a</a>)</span>. And
since the genealogies of human languages are still incompletely known,
it is imperative to make our phylogenetic hypotheses and assumptions as
explicit and as testable as possible. In this document, we hope have
shown that doing so is entirely feasible.</p>
<p>Through the use of <code>glottoTrees</code> and
<code>phyloWeights</code>, we hope that in the future, linguistic trees
and the code used to produce them can be published together with
typological studies. This will enable subsequent researchers to
replicate the study’s findings, and just as importantly, to modify its
assumptions by modifying the trees, and thereby to test further
hypotheses inspired by the initial research.</p>
<p>If you find these practical tools useful in your own research, please
cite the packages as <span class="citation">Round (<a
href="#ref-glottoTrees" role="doc-biblioref">2021a</a>)</span> and <span
class="citation">Round (<a href="#ref-phyloWeights"
role="doc-biblioref">2021b</a>)</span>. If you wish to cite the notion
of genealogically-sensitive averages and proportions, please cite either
<span class="citation">Macklin-Cordes and Round (<a
href="#ref-macklin-cordes_challenges_nodate"
role="doc-biblioref">2021a</a>)</span> and/or the more specific
references therein.</p>
<p>If you think you’ve encountered a bug or anomalous behaviour in
<code>glottoTrees</code> and <code>phyloWeights</code>, please be in
contact, either through the package github pages or by email: <a
href="mailto:e.round@uq.edu.au" class="email">e.round@uq.edu.au</a>.
It’s important for the good of the science that linguists can use these
methods without undue impediments.</p>
</div>
<div id="citation-session-info" class="section level1 unnumbered">
<h1 class="unnumbered">Citation &amp; Session Info</h1>
<p>Round, Erich. 2022. <em>Practical phylogenetic comparative methods
for linguistic typology</em>. Surrey Morphology Group, University of
Surrey &amp; Ancient Language Lab, University of Queensland. url: <a
href="https://slcladal.github.io/phylo_for_typology.html"
class="uri">https://slcladal.github.io/phylo_for_typology.html</a>
(Version 2022.07.30).</p>
<pre><code>@manual{Round2022net,
  author = {Round, Erich},
  title = {Practical phylogenetic comparative methods for linguistic typology},
  note = {https://slcladal.github.io/phylo_for_typology.html},
  year = {2022},
  organization = {{Surrey Morphology Group, University of Surrey} and {Ancient Language Lab, School of Languages and Cultures, University of Queensland}},
  address = {{Guildford, UK} and {St Lucia, QLD}},
  edition = {2022.07.30}
}</code></pre>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 4.2.1 RC (2022-06-17 r82510 ucrt)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 19043)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=German_Germany.utf8  LC_CTYPE=German_Germany.utf8   
## [3] LC_MONETARY=German_Germany.utf8 LC_NUMERIC=C                   
## [5] LC_TIME=German_Germany.utf8    
## 
## attached base packages:
## [1] stats     graphics  grDevices datasets  utils     methods   base     
## 
## other attached packages:
##  [1] ape_5.6-2             glottoTrees_0.1.0006  phyloWeights_0.3.0005
##  [4] flextable_0.7.0       forcats_0.5.1         stringr_1.4.0        
##  [7] dplyr_1.0.9           purrr_0.3.4           readr_2.1.2          
## [10] tidyr_1.2.0           tibble_3.1.7          ggplot2_3.3.6        
## [13] tidyverse_1.3.1      
## 
## loaded via a namespace (and not attached):
##  [1] nlme_3.1-157            fs_1.5.2                lubridate_1.8.0        
##  [4] httr_1.4.3              numDeriv_2016.8-1.1     tools_4.2.1            
##  [7] backports_1.4.1         bslib_0.3.1             utf8_1.2.2             
## [10] R6_2.5.1                DBI_1.1.2               colorspace_2.0-3       
## [13] withr_2.5.0             phangorn_2.8.1          tidyselect_1.1.2       
## [16] mnormt_2.0.2            compiler_4.2.1          cli_3.3.0              
## [19] rvest_1.0.2             expm_0.999-6            xml2_1.3.3             
## [22] officer_0.4.2           sass_0.4.1              scales_1.2.0           
## [25] quadprog_1.5-8          systemfonts_1.0.4       digest_0.6.29          
## [28] rmarkdown_2.14          base64enc_0.1-3         pkgconfig_2.0.3        
## [31] htmltools_0.5.2         plotrix_3.8-2           dbplyr_2.1.1           
## [34] fastmap_1.1.0           highr_0.9               maps_3.4.0             
## [37] rlang_1.0.2             readxl_1.4.0            rstudioapi_0.13        
## [40] jquerylib_0.1.4         generics_0.1.2          combinat_0.0-8         
## [43] jsonlite_1.8.0          zip_2.2.0               magrittr_2.0.3         
## [46] Matrix_1.4-1            Rcpp_1.0.8.3            munsell_0.5.0          
## [49] fansi_1.0.3             gdtools_0.2.4           lifecycle_1.0.1        
## [52] scatterplot3d_0.3-41    stringi_1.7.6           yaml_2.3.5             
## [55] clusterGeneration_1.3.7 MASS_7.3-57             grid_4.2.1             
## [58] parallel_4.2.1          crayon_1.5.1            lattice_0.20-45        
## [61] haven_2.5.0             hms_1.1.1               tmvnsim_1.0-2          
## [64] klippy_0.0.0.9500       knitr_1.39              pillar_1.7.0           
## [67] igraph_1.3.1            uuid_1.1-0              codetools_0.2-18       
## [70] fastmatch_1.1-3         reprex_2.0.1            glue_1.6.2             
## [73] evaluate_0.15           data.table_1.14.2       renv_0.15.4            
## [76] modelr_0.1.8            vctrs_0.4.1             tzdb_0.3.0             
## [79] cellranger_1.1.0        gtable_0.3.0            assertthat_0.2.1       
## [82] xfun_0.30               broom_0.8.0             phytools_1.0-3         
## [85] coda_0.19-4             ellipsis_0.3.2</code></pre>
<hr />
<p><a href="#introduction">Back to top</a></p>
<p><a href="https://slcladal.github.io/index.html">Back to HOME</a></p>
<hr />
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-altschul_weights_1989" class="csl-entry">
Altschul, Stephen F., Raymond J. Carroll, and David J. Lipman. 1989.
<span>“Weights for Data Related by a Tree.”</span> <em>Journal of
Molecular Biology</em> 207 (4): 647–53.
</div>
<div id="ref-anderson2018clics2" class="csl-entry">
Anderson, Cormac, Robert Forkel, Simon J Greenhill, Johann-Mattis List,
Christoph Rzymski, and Tiago Tresoldi. 2018. <span>“<span>Clics2</span>:
An Improved Database of Cross-Linguistic Colexifications Assembling
Lexical Data with the Help of Cross-Linguistic Data Formats.”</span>
<em>Linguistic Typology</em> 22 (2): 277–306.
</div>
<div id="ref-Newick" class="csl-entry">
Felsenstein, Joseph. n.d. <em>The <span>Newick</span> Tree Format</em>.
<a
href="http://evolution.genetics.washington.edu/phylip/newicktree.html">http://evolution.genetics.washington.edu/phylip/newicktree.html</a>.
</div>
<div id="ref-green_proto_2003" class="csl-entry">
Green, Rebecca. 2003. <span>“Proto <span>Maningrida</span> with Proto
<span>Arnhem</span>: Evidence from Verbal Inflectional Suffixes.”</span>
In <em>The Non-<span>Pama</span>-<span>Nyungan</span> Languages of
Northern <span>Australia</span> : Comparative Studies of the Continent’s
Most Linguistically Complex Region</em>, edited by Nicholas Evans,
369–421. Pacific Linguistics.
</div>
<div id="ref-glottolog" class="csl-entry">
Hammarström, Harald, Robert Forkel, Martin Haspelmath, and Sebastian
Bank. 2021. <em>Glottolog 4.4</em>. Leipzig: Max Planck Institute for
Evolutionary Anthropology. <a
href="https://doi.org/10.5281/zenodo.4761960">https://doi.org/10.5281/zenodo.4761960</a>.
</div>
<div id="ref-macklin-cordes_challenges_nodate" class="csl-entry">
Macklin-Cordes, Jayden, and Erich R Round. 2021a. <span>“Challenges of
Sampling and How Phylogenetic Comparative Methods Help:
<span>With</span> a Case Study of the
<span>Pama</span>-<span>Nyungan</span> Laminal Contrast.”</span>
</div>
<div id="ref-macklin-cordes_phylogenetic_2021" class="csl-entry">
———. 2021b. <span>“Phylogenetic Comparative Methods: <span>What</span>
All the Fuss Is about, and How to Use Them in Everyday Research.”</span>
Brisbane.
</div>
<div id="ref-round_ausphon-lexicon_2017" class="csl-entry">
Round, Erich R. 2017. <span>“The
<span>AusPhon</span>-<span>Lexicon</span> Project: 2 Million Normalized
Segments Across 300 <span>Australian</span> Languages.”</span>
</div>
<div id="ref-glottoTrees" class="csl-entry">
———. 2021a. <em><span class="nocase">glottoTrees</span>: Phylogenetic
Trees in Linguistics.</em> <a
href="https://github.com/erichround/glottoTrees">https://github.com/erichround/glottoTrees</a>.
</div>
<div id="ref-phyloWeights" class="csl-entry">
———. 2021b. <em><span class="nocase">phyloWeights</span>: Calculation of
Genealogically-Sensitive Proportions and Averages</em>. <a
href="https://github.com/erichround/phyloWeights">https://github.com/erichround/phyloWeights</a>.
</div>
<div id="ref-stone_constructing_2007" class="csl-entry">
Stone, Eric A., and Arend Sidow. 2007. <span>“Constructing a Meaningful
Evolutionary Average at the Phylogenetic Center of Mass.”</span> <em>BMC
Bioinformatics</em> 8 (1): 222.
</div>
<div id="ref-venditti2010phylogenies" class="csl-entry">
Venditti, Chris, Andrew Meade, and Mark Pagel. 2010. <span>“Phylogenies
Reveal New Interpretation of Speciation and the Red Queen.”</span>
<em>Nature</em> 463 (7279): 349–52.
</div>
<div id="ref-yin_violations_2020" class="csl-entry">
Yin, Ruihua. 2020. <span>“Violations of the Sonority Sequencing
Principle: <span>How</span>, and How Often?”</span> <a
href="https://als.asn.au/Conference/Program">https://als.asn.au/Conference/Program</a>.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>See online documentation of the <code>ape</code> package
for reading trees from various common file formats.<a href="#fnref1"
class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Although this file is named
<code>tree_glottolog_newick.txt</code>, it is not in true Newick format
due to its use of square brackets in node and tip labels <span
class="citation">(<a href="#ref-Newick"
role="doc-biblioref">Felsenstein, n.d.</a>)</span>. In
<code>glottoTrees</code>, the square brackets in glottolog’s file are
converted to angled brackets (i.e., greater-than and less-than symbols),
to bring them into conformity with the Newick standard.<a href="#fnref2"
class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>There are two exceptional glottocodes with numbers in
the initial four characters: b10b1234 and 3adt1234.<a href="#fnref3"
class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>The differences are systematic and are made in order to
conform with the permissible Newick format of tree labels: spaces and
apostrophes are removed, parentheses are replaced by braces, and commas
are replaced by forward slashes.<a href="#fnref4"
class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p><code>glottoTrees</code> currently contains information
from glottolog versions 4.0, 4.1, 4.2, 4.3 and 4.4 (which is current at
time of writing). Our intention is to update <code>glottoTrees</code> as
glottolog updates in the future.<a href="#fnref5"
class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>Converting nodes into tips may cause them to move to the
left or right in the tree plot. The movement is meaningless, since a
subgroup (A, B) is exactly the same as subgroup (B, A). Since the
movement is meaningless, it’s also harmless.<a href="#fnref6"
class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p><code>apply_duplicate_suffixes()</code> will also add
suffixes to any nodes with duplicate labels.<a href="#fnref7"
class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>‘Most likely’ doesn’t mean that we expect to see trees
with exactly these branch lengths. Compare this to flipping a coin two
million times: although it is unlikely that the outcome will be exactly
one million heads and one million tails, it remains true that one
million heads and one million tails is the most likely outcome, in the
strict sense that it is more likely than any other outcome. The branch
lengths discussed here are ‘most likely’ is a similar sense.<a
href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p><a href="https://github.com/rambaut/figtree/releases"
class="uri">https://github.com/rambaut/figtree/releases</a><a
href="#fnref9" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
